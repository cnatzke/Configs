Vim: Warning: Output is not to a terminal
chdir(/etc)[?25l[J
fchdir() to previous dir[J
sourcing "/etc/vimrc"[J
line 1: " All system-wide defaults are set in $VIMRUNTIME/archlinux.vim (usually just[J

line 2: " /usr/share/vim/vimfiles/archlinux.vim) and sourced by the call to :runtime[J

line 3: " you can find below.  If you wish to change any of those settings, you should[J

line 4: " do it in this file (/etc/vimrc), since archlinux.vim will be overwritten[J

line 5: " everytime an upgrade of the vim packages is performed.  It is recommended to[J

line 6: " make changes after sourcing archlinux.vim since it alters the value of the[J

line 7: " 'compatible' option.[J

line 8: [J

line 9: " This line should not be removed as it ensures that various options are[J

line 10: " properly set to work with the Vim-related packages.[J

line 11: runtime! archlinux.vim[J

Searching for "archlinux.vim" in "/home/connor/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/archlinux.vim"[J
Searching for "/usr/share/vim/vimfiles/archlinux.vim"[J
chdir(/usr/share/vim/vimfiles)[J
fchdir() to previous dir[J
line 11: sourcing "/usr/share/vim/vimfiles/archlinux.vim"[J
line 1: " The ArchLinux global vimrc - setting only a few sane defaults[J

line 2: "[J

line 3: " NEVER EDIT THIS FILE, IT'S OVERWRITTEN UPON UPGRADES, GLOBAL CONFIGURATION[J

line 4: " SHALL BE DONE IN /etc/vimrc, USER SPECIFIC CONFIGURATION IN ~/.vimrc[J

line 5: [J

line 6: " Normally we use vim-extensions. If you want true vi-compatibility[J

line 7: " remove change the following statements[J

line 8: set nocompatible                " Use Vim defaults instead of 100% vi compatibility[J

line 9: set backspace=indent,eol,start  " more powerful backspacing[J

line 10: [J

line 11: " Now we set some defaults for the editor[J

line 12: set history=50                  " keep 50 lines of command line history[J

line 13: set ruler                       " show the cursor position all the time[J

line 14: [J

line 15: " Suffixes that get lower priority when doing tab completion for filenames.[J

line 16: " These are files we are not likely to want to edit or read.[J

line 17: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.png,.jpg[J

line 18: [J

line 19: " Move the swap file location to protect against CVE-2017-1000382[J

line 20: if exists('$XDG_CACHE_HOME')[J

line 21: ^Ilet &g:directory=$XDG_CACHE_HOME[J

line 22: else[J

line 23: ^Ilet &g:directory=$HOME . '/.cache'[J

line 24: endif[J

line 25: let &g:directory.='/vim/swap//'[J

line 26: " Create swap directory if it doesn't exist[J

line 27: if ! isdirectory(expand(&g:directory))[J

line 28:   silent! call mkdir(expand(&g:directory), 'p', 0700)[J

line 29: endif[J

line 30: [J

line 31: if has('gui_running')[J

line 32:   " Make shift-insert work like in Xterm[J

line 33:   map <S-Insert> <MiddleMouse>[J

line 34:   map! <S-Insert> <MiddleMouse>[J

line 35: endif[J

finished sourcing /usr/share/vim/vimfiles/archlinux.vim[J
continuing in /etc/vimrc[J
Searching for "/usr/share/vim/vim81/archlinux.vim"[J
Searching for "/usr/share/vim/vimfiles/after/archlinux.vim"[J
Searching for "/home/connor/.vim/after/archlinux.vim"[J
line 12: [J

line 13: " If you prefer the old-style vim functionalty, add 'runtime! vimrc_example.vim'[J

line 14: " Or better yet, read /usr/share/vim/vim80/vimrc_example.vim or the vim manual[J

line 15: " and configure vim to your own liking![J

line 16: [J

line 17: " do not load defaults if ~/.vimrc is missing[J

line 18: "let skip_defaults_vim=1[J

finished sourcing /etc/vimrc[J
chdir(/home/connor)[J
fchdir() to previous dir[J
sourcing "$HOME/.vimrc"[J
line 1: " Experimental Vim set up[J

line 2: " C.Natzke Aug 16 2018[J

line 3: [J

line 4: " Pathogen set up[J

line 5: filetype off[J

Searching for "ftoff.vim" in "/home/connor/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/ftoff.vim"[J
Searching for "/usr/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/share/vim/vim81/ftoff.vim"[J
chdir(/usr/share/vim/vim81)[J
fchdir() to previous dir[J
line 5: sourcing "/usr/share/vim/vim81/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/share/vim/vim81/ftoff.vim[J
continuing in /home/connor/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/home/connor/.vim/after/ftoff.vim"[J
line 6: execute pathogen#infect()[J

Searching for "autoload/pathogen.vim" in "/home/connor/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/autoload/pathogen.vim"[J
chdir(/home/connor/.vim/autoload)[J
fchdir() to previous dir[J
line 6: sourcing "/home/connor/.vim/autoload/pathogen.vim"[J
line 1: " pathogen.vim - path option manipulation[J

line 2: " Maintainer:   Tim Pope <http://tpo.pe/>[J

line 3: " Version:      2.4[J

line 4: [J

line 5: " Install in ~/.vim/autoload (or ~\vimfiles\autoload).[J

line 6: "[J

line 7: " For management of individually installed plugins in ~/.vim/bundle (or[J

line 8: " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your[J

line 9: " .vimrc is the only other setup necessary.[J

line 10: "[J

line 11: " The API is documented inline below.[J

line 12: [J

line 13: if exists("g:loaded_pathogen") || &cp[J

line 14:   finish[J

line 15: endif[J

line 16: let g:loaded_pathogen = 1[J

line 17: [J

line 18: " Point of entry for basic default usage.  Give a relative path to invoke[J

line 19: " pathogen#interpose() or an absolute path to invoke pathogen#surround().[J

line 20: " Curly braces are expanded with pathogen#expand(): "bundle/{}" finds all[J

line 21: " subdirectories inside "bundle" inside all directories in the runtime path.[J

line 22: " If no arguments are given, defaults "bundle/{}", and also "pack/{}/start/{}"[J

line 23: " on versions of Vim without native package support.[J

line 24: function! pathogen#infect(...) abort[J

line 50: [J

line 51: " Split a path into a list.[J

line 52: function! pathogen#split(path) abort[J

line 58: [J

line 59: " Convert a list to a path.[J

line 60: function! pathogen#join(...) abort[J

line 85: [J

line 86: " Convert a list to a path with escaped spaces for 'path', 'tag', etc.[J

line 87: function! pathogen#legacyjoin(...) abort[J

line 90: [J

line 91: " Turn filetype detection off and back on again if it was already enabled.[J

line 92: function! pathogen#cycle_filetype() abort[J

line 98: [J

line 99: " Check if a bundle is disabled.  A bundle is considered disabled if its[J

line 100: " basename or full name is included in the list g:pathogen_blacklist or the[J

line 101: " comma delimited environment variable $VIMBLACKLIST.[J

line 102: function! pathogen#is_disabled(path) abort[J

line 113: [J

line 114: " Prepend the given directory to the runtime path and append its corresponding[J

line 115: " after directory.  Curly braces are expanded with pathogen#expand().[J

line 116: function! pathogen#surround(path) abort[J

line 126: [J

line 127: " For each directory in the runtime path, add a second entry with the given[J

line 128: " argument appended.  Curly braces are expanded with pathogen#expand().[J

line 129: function! pathogen#interpose(name) abort[J

line 147: [J

line 148: let s:done_bundles = {}[J

line 149: [J

line 150: " Invoke :helptags on all non-$VIM doc directories in runtimepath.[J

line 151: function! pathogen#helptags() abort[J

line 161: [J

line 162: command! -bar Helptags :call pathogen#helptags()[J

line 163: [J

line 164: " Execute the given command.  This is basically a backdoor for --remote-expr.[J

line 165: function! pathogen#execute(...) abort[J

line 171: [J

line 172: " Section: Unofficial[J

line 173: [J

line 174: function! pathogen#is_absolute(path) abort[J

line 177: [J

line 178: " Given a string, returns all possible permutations of comma delimited braced[J

line 179: " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields[J

line 180: " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard[J

line 181: " and globbed.  Actual globs are preserved.[J

line 182: function! pathogen#expand(pattern, ...) abort[J

line 203: [J

line 204: " \ on Windows unless shellslash is set, / everywhere else.[J

line 205: function! pathogen#slash() abort[J

line 208: [J

line 209: function! pathogen#separator() abort[J

line 212: [J

line 213: " Convenience wrapper around glob() which returns a list.[J

line 214: function! pathogen#glob(pattern) abort[J

line 218: [J

line 219: " Like pathogen#glob(), only limit the results to directories.[J

line 220: function! pathogen#glob_directories(pattern) abort[J

line 223: [J

line 224: " Remove duplicates from a list.[J

line 225: function! pathogen#uniq(list) abort[J

line 241: [J

line 242: " Backport of fnameescape().[J

line 243: function! pathogen#fnameescape(string) abort[J

line 252: [J

line 253: " Like findfile(), but hardcoded to use the runtimepath.[J

line 254: function! pathogen#runtime_findfile(file,count) abort[J

line 263: [J

line 264: " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':[J

finished sourcing /home/connor/.vim/autoload/pathogen.vim[J
continuing in /home/connor/.vimrc[J
calling function pathogen#infect[J()

line 1:   if a:0[J

line 2:     let paths = filter(reverse(copy(a:000)), 'type(v:val) == type("")')[J

line 3:   else[J

line 4:     let paths = ['bundle/{}', 'pack/{}/start/{}'][J

line 5:   endif[J

line 6:   if has('packages')[J

line 7:     call filter(paths, 'v:val !~# "^pack/[^/]*/start/[^/]*$"')[J

line 8:   endif[J

line 9:   let static = '^\%([$~\\/]\|\w:[\\/]\)[^{}*]*$'[J

line 10:   for path in filter(copy(paths), 'v:val =~# static')[J

line 11:     call pathogen#surround(path)[J

line 12:   endfor[J

line 13:   for path in filter(copy(paths), 'v:val !~# static')[J

line 14:     if path =~# '^\%([$~\\/]\|\w:[\\/]\)'[J

line 15:       call pathogen#surround(path)[J

line 16:     else[J

line 17:       call pathogen#interpose(path)[J

calling function pathogen#infect[17]..pathogen#interpose[J('bundle/{}')

line 1:   let sep = pathogen#slash()[J

calling function pathogen#infect[17]..pathogen#interpose[1]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[1]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 2:   let name = a:name[J

line 3:   if has_key(s:done_bundles, name)[J

line 4:     return ""[J

line 5:   endif[J

line 6:   let s:done_bundles[name] = 1[J

line 7:   let list = [][J

line 8:   for dir in pathogen#split(&rtp)[J

calling function pathogen#infect[17]..pathogen#interpose[8]..pathogen#split[J('/home/connor/.vim,/usr/share/vim/vimf...vimfiles/after,/home/connor/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   if empty(a:path) | return [] | endif[J

line 2:  return [] | endif[J

line 2:  endif[J

line 3:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')[J

line 4:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')[J

function pathogen#infect[17]..pathogen#interpose[8]..pathogen#split returning ['/home/connor/.vim', '/usr/share/vim/...iles/after', '/home/connor/.vim/after'][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J('/home/connor/.vim/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''[J

line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')[J

line 3:   if pattern =~# '{[^{}]\+}'[J

line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)[J

line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')[J

line 6:     let results = [][J

line 7:     for pattern in found[J

line 8:       call extend(results, pathogen#expand(pattern))[J

line 9:     endfor[J

line 10:   elseif pattern =~# '{}'[J

line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')[J

line 12:     let post = pattern[strlen(pat) : -1][J

line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')[J

line 14:   else[J

line 15:     let results = [pattern][J

line 16:   endif[J

line 17:   let vf = pathogen#slash() . 'vimfiles'[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')[J

line 19:   return filter(results, '!empty(v:val)')[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning ['/home/connor/.vim/bundle/Vundle.vim'...home/connor/.vim/bundle/nerdcommenter'][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J('/home/connor/.vim/bundle/Vundle.vim')

line 1:   if a:path =~# '\~$'[J

line 2:     return 1[J

line 3:   endif[J

line 4:   let sep = pathogen#slash()[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split[J('')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   if empty(a:path) | return [] | endif[J

line 2:  return [] | endif[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 6:   if !empty(blacklist)[J

line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')[J

line 8:   endif[J

line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0[J

continuing in function pathogen#infect[17]..pathogen#interpose[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J('/home/connor/.vim/bundle/YouCompleteMe')

line 1:   if a:path =~# '\~$'[J

line 2:     return 1[J

line 3:   endif[J

line 4:   let sep = pathogen#slash()[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split[J('')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   if empty(a:path) | return [] | endif[J

line 2:  return [] | endif[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 6:   if !empty(blacklist)[J

line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')[J

line 8:   endif[J

line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0[J

continuing in function pathogen#infect[17]..pathogen#interpose[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J('/home/connor/.vim/bundle/nerdcommenter')

line 1:   if a:path =~# '\~$'[J

line 2:     return 1[J

line 3:   endif[J

line 4:   let sep = pathogen#slash()[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split[J('')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   if empty(a:path) | return [] | endif[J

line 2:  return [] | endif[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled[J

line 6:   if !empty(blacklist)[J

line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')[J

line 8:   endif[J

line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#is_disabled returning #0[J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J('/usr/share/vim/vimfiles/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''[J

line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')[J

line 3:   if pattern =~# '{[^{}]\+}'[J

line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)[J

line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')[J

line 6:     let results = [][J

line 7:     for pattern in found[J

line 8:       call extend(results, pathogen#expand(pattern))[J

line 9:     endfor[J

line 10:   elseif pattern =~# '{}'[J

line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')[J

line 12:     let post = pattern[strlen(pat) : -1][J

line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')[J

line 14:   else[J

line 15:     let results = [pattern][J

line 16:   endif[J

line 17:   let vf = pathogen#slash() . 'vimfiles'[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')[J

line 19:   return filter(results, '!empty(v:val)')[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J('/usr/share/vim/vim81/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''[J

line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')[J

line 3:   if pattern =~# '{[^{}]\+}'[J

line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)[J

line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')[J

line 6:     let results = [][J

line 7:     for pattern in found[J

line 8:       call extend(results, pathogen#expand(pattern))[J

line 9:     endfor[J

line 10:   elseif pattern =~# '{}'[J

line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')[J

line 12:     let post = pattern[strlen(pat) : -1][J

line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')[J

line 14:   else[J

line 15:     let results = [pattern][J

line 16:   endif[J

line 17:   let vf = pathogen#slash() . 'vimfiles'[J

calling function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[17]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand[J

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')[J

line 19:   return filter(results, '!empty(v:val)')[J

function pathogen#infect[17]..pathogen#interpose[12]..pathogen#expand returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[J('/usr/share/vim/vimfiles/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''[J

line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')[J

line 3:   if pattern =~# '{[^{}]\+}'[J

line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)[J

line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')[J

line 6:     let results = [][J

line 7:     for pattern in found[J

line 8:       call extend(results, pathogen#expand(pattern))[J

line 9:     endfor[J

line 10:   elseif pattern =~# '{}'[J

line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')[J

line 12:     let post = pattern[strlen(pat) : -1][J

line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')[J

line 14:   else[J

line 15:     let results = [pattern][J

line 16:   endif[J

line 17:   let vf = pathogen#slash() . 'vimfiles'[J

calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[J

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')[J

line 19:   return filter(results, '!empty(v:val)')[J

function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[J('/home/connor/.vim/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''[J

line 2:   let pattern = substitute(a:pattern, '^[~$][^\/]*', '\=expand(submatch(0))', '')[J

line 3:   if pattern =~# '{[^{}]\+}'[J

line 4:     let [pre, pat, post] = split(substitute(pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)[J

line 5:     let found = map(split(pat, ',', 1), 'pre.v:val.post')[J

line 6:     let results = [][J

line 7:     for pattern in found[J

line 8:       call extend(results, pathogen#expand(pattern))[J

line 9:     endfor[J

line 10:   elseif pattern =~# '{}'[J

line 11:     let pat = matchstr(pattern, '^.*{}[^*]*\%($\|[\\/]\)')[J

line 12:     let post = pattern[strlen(pat) : -1][J

line 13:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')[J

line 14:   else[J

line 15:     let results = [pattern][J

line 16:   endif[J

line 17:   let vf = pathogen#slash() . 'vimfiles'[J

calling function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[17]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand[J

line 18:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')[J

line 19:   return filter(results, '!empty(v:val)')[J

function pathogen#infect[17]..pathogen#interpose[10]..pathogen#expand returning [][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

line 13:     endif[J

line 14:   endfor[J

line 8:   for dir in pathogen#split(&rtp)[J

line 9:     if dir =~# '\<after$'[J

line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir][J

line 11:     else[J

line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')[J

line 13:     endif[J

line 14:   endfor[J

line 15:   let &rtp = pathogen#join(pathogen#uniq(list))[J

calling function pathogen#infect[17]..pathogen#interpose[15]..pathogen#uniq[J(['/home/connor/.vim', '/home/connor/.v...iles/after', '/home/connor/.vim/after'])

line 1:   let i = 0[J

line 2:   let seen = {}[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 3:   while i < len(a:list)[J

line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])[J

line 5:       call remove(a:list,i)[J

line 6:     elseif a:list[i] ==# ''[J

line 7:       let i += 1[J

line 8:       let empty = 1[J

line 9:     else[J

line 10:       let seen[a:list[i]] = 1[J

line 11:       let i += 1[J

line 12:     endif[J

line 13:   endwhile[J

line 14:   return a:list[J

function pathogen#infect[17]..pathogen#interpose[15]..pathogen#uniq returning ['/home/connor/.vim', '/home/connor/.v...iles/after', '/home/connor/.vim/after'][J

continuing in function pathogen#infect[17]..pathogen#interpose[J

calling function pathogen#infect[17]..pathogen#interpose[15]..pathogen#join[J(['/home/connor/.vim', '/home/connor/.v...iles/after', '/home/connor/.vim/after'])

line 1:   if type(a:1) == type(1) && a:1[J

line 2:     let i = 1[J

line 3:     let space = ' '[J

line 4:   else[J

line 5:     let i = 0[J

line 6:     let space = ''[J

line 7:   endif[J

line 8:   let path = ""[J

line 9:   while i < a:0[J

line 10:     if type(a:000[i]) == type([])[J

line 11:       let list = a:000[i][J

line 12:       let j = 0[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 18:     else[J

line 19:       let path .= "," . a:000[i][J

line 20:     endif[J

line 21:     let i += 1[J

line 22:   endwhile[J

line 9:   while i < a:0[J

line 10:     if type(a:000[i]) == type([])[J

line 11:       let list = a:000[i][J

line 12:       let j = 0[J

line 13:       while j < len(list)[J

line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')[J

line 15:         let path .= ',' . escaped[J

line 16:         let j += 1[J

line 17:       endwhile[J

line 18:     else[J

line 19:       let path .= "," . a:000[i][J

line 20:     endif[J

line 21:     let i += 1[J

line 22:   endwhile[J

line 23:   return substitute(path,'^,','','')[J

function pathogen#infect[17]..pathogen#interpose[15]..pathogen#join returning '/home/connor/.vim,/home/connor/.vim/b...vimfiles/after,/home/connor/.vim/after'[J

continuing in function pathogen#infect[17]..pathogen#interpose[J

line 16:   return 1[J

function pathogen#infect[17]..pathogen#interpose returning #1[J

continuing in function pathogen#infect[J

line 18:     endif[J

line 19:   endfor[J

line 13:   for path in filter(copy(paths), 'v:val !~# static')[J

line 14:     if path =~# '^\%([$~\\/]\|\w:[\\/]\)'[J

line 15:       call pathogen#surround(path)[J

line 16:     else[J

line 17:       call pathogen#interpose(path)[J

line 18:     endif[J

line 19:   endfor[J

line 20:   call pathogen#cycle_filetype()[J

calling function pathogen#infect[20]..pathogen#cycle_filetype[J()

line 1:   if exists('g:did_load_filetypes')[J

line 2:     filetype off[J

line 3:     filetype on[J

line 4:   endif[J

function pathogen#infect[20]..pathogen#cycle_filetype returning #0[J

continuing in function pathogen#infect[J

line 21:   if pathogen#is_disabled($MYVIMRC)[J

calling function pathogen#infect[21]..pathogen#is_disabled[J('/home/connor/.vimrc')

line 1:   if a:path =~# '\~$'[J

line 2:     return 1[J

line 3:   endif[J

line 4:   let sep = pathogen#slash()[J

calling function pathogen#infect[21]..pathogen#is_disabled[4]..pathogen#slash[J()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'[J

function pathogen#infect[21]..pathogen#is_disabled[4]..pathogen#slash returning '/'[J

continuing in function pathogen#infect[21]..pathogen#is_disabled[J

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)[J

calling function pathogen#infect[21]..pathogen#is_disabled[5]..pathogen#split[J('')

line 1:   if type(a:path) == type([]) | return a:path | endif[J

line 1:  return a:path | endif[J

line 1:  endif[J

line 2:   if empty(a:path) | return [] | endif[J

line 2:  return [] | endif[J

function pathogen#infect[21]..pathogen#is_disabled[5]..pathogen#split returning [][J

continuing in function pathogen#infect[21]..pathogen#is_disabled[J

line 6:   if !empty(blacklist)[J

line 7:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')[J

line 8:   endif[J

line 9:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1[J

function pathogen#infect[21]..pathogen#is_disabled returning #0[J

continuing in function pathogen#infect[J

line 22:     return 'finish'[J

line 23:   endif[J

line 24:   return ''[J

function pathogen#infect returning ''[J

continuing in /home/connor/.vimrc[J

line 6: [J

line 7: filetype plugin indent on[J

Searching for "filetype.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/filetype.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/filetype.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/filetype.vim"[J
Searching for "/usr/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/share/vim/vim81/filetype.vim"[J
chdir(/usr/share/vim/vim81)[J
fchdir() to previous dir[J
line 7: sourcing "/usr/share/vim/vim81/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2018 May 04[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.pacsave,?\+.pacnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Vim help file[J

line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help[J

line 53: [J

line 54: " Abaqus or Trasys[J

line 55: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()[J

line 56: [J

line 57: " A-A-P recipe[J

line 58: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 59: [J

line 60: " A2ps printing utility[J

line 61: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 62: [J

line 63: " ABAB/4[J

line 64: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 65: [J

line 66: " ABC music notation[J

line 67: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 68: [J

line 69: " ABEL[J

line 70: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 71: [J

line 72: " AceDB[J

line 73: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 74: [J

line 75: " Ada (83, 9X, 95)[J

line 76: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 77: if has("vms")[J

line 78:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 79: else[J

line 80:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 81: endif[J

line 82: [J

line 83: " AHDL[J

line 84: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 85: [J

line 86: " AMPL[J

line 87: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 88: [J

line 89: " Ant[J

line 90: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 91: [J

line 92: " Arduino[J

line 93: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino[J

line 94: [J

line 95: " Apache style config file[J

line 96: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 97: [J

line 98: " Apache config file[J

line 99: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache[J

line 100: [J

line 101: " XA65 MOS6510 cross assembler[J

line 102: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 103: [J

line 104: " Applescript[J

line 105: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 106: [J

line 107: " Applix ELF[J

line 109: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 110: [J

line 111: " ALSA configuration[J

line 112: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf[J

line 113: [J

line 114: " Arc Macro Language[J

line 115: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 116: [J

line 117: " APT config file[J

line 118: au BufNewFile,BufRead apt.conf^I^I       setf aptconf[J

line 119: au BufNewFile,BufRead */.aptitude/config       setf aptconf[J

line 120: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf[J

line 121: [J

line 122: " Arch Inventory file[J

line 123: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 124: [J

line 125: " ART*Enterprise (formerly ART-IM)[J

line 126: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 127: [J

line 128: " AsciiDoc[J

line 129: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc[J

line 130: [J

line 131: " ASN.1[J

line 132: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 133: [J

line 134: " Active Server Pages (with Visual Basic Script)[J

line 140: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 141: [J

line 142: " Active Server Pages (with Perl or Visual Basic Script)[J

line 150: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 151: [J

line 152: " Grub (must be before catch *.lst)[J

line 153: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub[J

line 154: [J

line 155: " Assembly (all kinds)[J

line 156: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 157: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()[J

line 158: [J

line 159: " Macro (VAX)[J

line 160: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 161: [J

line 162: " Atlas[J

line 163: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 164: [J

line 165: " Autoit v3[J

line 166: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 167: [J

line 168: " Autohotkey[J

line 169: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 170: [J

line 171: " Automake[J

line 172: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 173: [J

line 174: " Autotest .at files are actually m4[J

line 175: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 176: [J

line 177: " Avenue[J

line 178: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 179: [J

line 180: " Awk[J

line 181: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 182: [J

line 183: " B[J

line 184: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 185: [J

line 186: " BASIC or Visual Basic[J

line 187: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")[J

line 188: [J

line 189: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET[J

line 190: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb[J

line 191: [J

line 192: " IBasic file (similar to QBasic)[J

line 193: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 194: [J

line 195: " FreeBasic file (similar to QBasic)[J

line 196: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 197: [J

line 198: " Batch file for MSDOS.[J

line 199: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 200: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 202: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 203: [J

line 204: " Batch file for 4DOS[J

line 205: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()[J

line 206: [J

line 207: " BC calculator[J

line 208: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 209: [J

line 210: " BDF font[J

line 211: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 212: [J

line 213: " BibTeX bibliography database file[J

line 214: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 215: [J

line 216: " BibTeX Bibliography Style[J

line 217: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 218: [J

line 219: " BIND configuration[J

line 220: " sudoedit uses namedXXXX.conf[J

line 221: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named[J

line 222: [J

line 223: " BIND zone[J

line 224: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 225: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')[J

line 226: [J

line 227: " Blank[J

line 228: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 229: [J

line 230: " Blkid cache file[J

line 231: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml[J

line 232: [J

line 233: " Bazel (http://bazel.io)[J

line 234: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl[J

line 235: if has("fname_case")[J

line 236:   " There is another check for BUILD further below.[J

line 237:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl[J

line 238: endif[J

line 239: [J

line 240: " C or lpc[J

line 241: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()[J

line 242: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc[J

line 243: [J

line 244: " Calendar[J

line 245: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 246: [J

line 247: " C#[J

line 248: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 249: [J

line 250: " CSDL[J

line 251: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl[J

line 252: [J

line 253: " Cabal[J

line 254: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal[J

line 255: [J

line 256: " Cdrdao TOC[J

line 257: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 258: [J

line 259: " Cdrdao config[J

line 260: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf[J

line 261: [J

line 262: " Cfengine[J

line 263: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 264: [J

line 265: " ChaiScript[J

line 266: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 267: [J

line 268: " Comshare Dimension Definition Language[J

line 269: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 270: [J

line 271: " Conary Recipe[J

line 272: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 273: [J

line 274: " Controllable Regex Mutilator[J

line 275: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 276: [J

line 277: " Cyn++[J

line 278: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 279: [J

line 280: " Cynlib[J

line 281: " .cc and .cpp files can be C++ or Cynlib.[J

line 283: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 285: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 286: [J

line 287: " C++[J

line 288: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 289: if has("fname_case")[J

line 290:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 291: endif[J

line 292: [J

line 293: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 294: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 295: " detected automatically.[J

line 296: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()[J

line 297: [J

line 298: " Ch (CHscript)[J

line 299: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 300: [J

line 301: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 302: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 303: [J

line 304: " Cascading Style Sheets[J

line 305: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 306: [J

line 307: " Century Term Command Scripts (*.cmd too)[J

line 308: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 309: [J

line 310: " Changelog[J

line 312: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 313: [J

line 319: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 320: [J

line 324: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 325: [J

line 326: " CHILL[J

line 327: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 328: [J

line 329: " Changes for WEB and CWEB or CHILL[J

line 330: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()[J

line 331: [J

line 332: " ChordPro[J

line 333: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 334: [J

line 335: " Clean[J

line 336: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 337: [J

line 338: " Clever[J

line 339: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 340: [J

line 341: " Clever or dtd[J

line 342: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()[J

line 343: [J

line 344: " Clipper (or FoxPro; could also be eviews)[J

line 350: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 351: [J

line 352: " Clojure[J

line 353: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure[J

line 354: [J

line 355: " Cmake[J

line 356: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 357: [J

line 358: " Cmusrc[J

line 359: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 360: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 361: [J

line 362: " Cobol[J

line 363: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 364: "   cobol or zope form controller python script? (heuristic)[J

line 370: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 371: [J

line 372: " Coco/R[J

line 373: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 374: [J

line 375: " Cold Fusion[J

line 376: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 377: [J

line 378: " Configure scripts[J

line 379: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 380: [J

line 381: " CUDA  Cumpute Unified Device Architecture[J

line 382: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda[J

line 383: [J

line 384: " Dockerfile[J

line 385: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile[J

line 386: [J

line 387: " WildPackets EtherPeek Decoder[J

line 388: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 389: [J

line 390: " Enlightenment configuration files[J

line 391: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 392: [J

line 393: " Eterm[J

line 394: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 395: [J

line 396: " Euphoria 3 or 4[J

line 397: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()[J

line 398: if has("fname_case")[J

line 399:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()[J

line 400: endif[J

line 401: [J

line 402: " Lynx config files[J

line 403: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 404: [J

line 405: " Quake[J

line 406: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 407: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 408: [J

line 409: " Quake C[J

line 410: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 411: [J

line 412: " Configure files[J

line 413: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 414: [J

line 415: " Cucumber[J

line 416: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber[J

line 417: [J

line 418: " Communicating Sequential Processes[J

line 419: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 420: [J

line 421: " CUPL logic description and simulation[J

line 422: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 423: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 424: [J

line 425: " Debian Control[J

line 426: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 430: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 431: [J

line 432: " Debian Copyright[J

line 433: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright[J

line 437: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif[J

line 438: [J

line 439: " Debian Sources.list[J

line 440: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources[J

line 441: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources[J

line 442: [J

line 443: " Deny hosts[J

line 444: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 445: [J

line 446: " dnsmasq(8) configuration files[J

line 447: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq[J

line 448: [J

line 449: " ROCKLinux package description[J

line 450: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 451: [J

line 452: " the D language or dtrace[J

line 453: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()[J

line 454: [J

line 455: " Desktop files[J

line 456: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 457: [J

line 458: " Dict config[J

line 459: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 460: [J

line 461: " Dictd config[J

line 462: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 463: [J

line 464: " Diff files[J

line 465: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff[J

line 471: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif[J

line 472: [J

line 473: " Dircolors[J

line 474: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors[J

line 475: [J

line 476: " Diva (with Skill) or InstallShield[J

line 482: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 483: [J

line 484: " DCL (Digital Command Language - vms) or DNS zone file[J

line 485: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')[J

line 486: [J

line 487: " DOT[J

line 488: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 489: [J

line 490: " Dylan - lid files[J

line 491: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 492: [J

line 493: " Dylan - intr files (melange)[J

line 494: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 495: [J

line 496: " Dylan[J

line 497: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 498: [J

line 499: " Microsoft Module Definition[J

line 500: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 501: [J

line 502: " Dracula[J

line 503: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 504: [J

line 505: " Datascript[J

line 506: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 507: [J

line 508: " dsl[J

line 509: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 510: [J

line 511: " DTD (Document Type Definition for XML)[J

line 512: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 513: [J

line 514: " DTS/DSTI (device tree files)[J

line 515: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts[J

line 516: [J

line 517: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn[J

line 518: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif[J

line 524: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif[J

line 525: [J

line 526: " EditorConfig (close enough to dosini)[J

line 527: au BufNewFile,BufRead .editorconfig^I^Isetf dosini[J

line 528: [J

line 529: " Embedix Component Description[J

line 530: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 531: [J

line 532: " Eiffel or Specman or Euphoria[J

line 533: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()[J

line 534: [J

line 535: " Elinks configuration[J

line 536: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 537: [J

line 538: " ERicsson LANGuage; Yaws is erlang too[J

line 539: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 540: [J

line 541: " Elm Filter Rules file[J

line 542: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 543: [J

line 544: " ESMTP rc file[J

line 545: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 546: [J

line 547: " ESQL-C[J

line 548: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 549: [J

line 550: " Esterel[J

line 551: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 552: [J

line 553: " Essbase script[J

line 554: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 555: [J

line 556: " Exim[J

line 557: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 558: [J

line 559: " Expect[J

line 560: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 561: [J

line 562: " Exports[J

line 563: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 564: [J

line 565: " Falcon[J

line 566: au BufNewFile,BufRead *.fal^I^I^Isetf falcon[J

line 567: [J

line 568: " Fantom[J

line 569: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 570: [J

line 571: " Factor[J

line 572: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 573: [J

line 574: " Fetchmail RC file[J

line 575: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 576: [J

line 577: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 578: " is not actually FlexWiki[J

line 579: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 580: [J

line 581: " Focus Executable[J

line 582: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 583: [J

line 584: " Focus Master file (but not for auto.master)[J

line 585: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 586: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 587: [J

line 588: " Forth[J

line 589: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 590: [J

line 591: " Reva Forth[J

line 592: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 593: [J

line 594: " Fortran[J

line 595: if has("fname_case")[J

line 596:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 597: endif[J

line 598: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 599: [J

line 600: " Framescript[J

line 601: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 602: [J

line 603: " FStab[J

line 604: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 605: [J

line 606: " GDB command files[J

line 607: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 608: [J

line 609: " GDMO[J

line 610: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 611: [J

line 612: " Gedcom[J

line 613: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 614: [J

line 615: " Git[J

line 616: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit[J

line 617: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig[J

line 618: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig[J

line 619: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig[J

line 620: if !empty($XDG_CONFIG_HOME)[J

line 621:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig[J

line 622: endif[J

line 623: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase[J

line 624: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail[J

line 628: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 632: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 633: [J

line 634: " Gkrellmrc[J

line 635: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 636: [J

line 637: " GP scripts (2.0 and onward)[J

line 638: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 639: [J

line 640: " GPG[J

line 641: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 642: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 643: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg[J

line 644: if !empty($GNUPGHOME)[J

line 645:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg[J

line 646:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg[J

line 647: endif[J

line 648: [J

line 649: " gnash(1) configuration files[J

line 650: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash[J

line 651: [J

line 652: " Gitolite[J

line 653: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite[J

line 654: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')[J

line 655: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl[J

line 656: [J

line 657: " Gnuplot scripts[J

line 658: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 659: [J

line 660: " Go (Google)[J

line 661: au BufNewFile,BufRead *.go^I^I^Isetf go[J

line 662: [J

line 663: " GrADS scripts[J

line 664: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 665: [J

line 666: " Gretl[J

line 667: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 668: [J

line 669: " Groovy[J

line 670: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy[J

line 671: [J

line 672: " GNU Server Pages[J

line 673: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 674: [J

line 675: " Group file[J

line 676: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group[J

line 677: [J

line 678: " GTK RC[J

line 679: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 680: [J

line 681: " Haml[J

line 682: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 683: [J

line 684: " Hamster Classic | Playground files[J

line 685: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 686: [J

line 687: " Haskell[J

line 688: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell[J

line 689: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 690: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 691: [J

line 692: " Haste[J

line 693: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 694: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 695: [J

line 696: " Hercules[J

line 697: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules[J

line 698: [J

line 699: " HEX (Intel)[J

line 700: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 701: [J

line 702: " Tilde (must be before HTML)[J

line 703: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 704: [J

line 705: " HTML (.shtml and .stm for server side)[J

line 706: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()[J

line 707: [J

line 708: " HTML with Ruby - eRuby[J

line 709: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 710: [J

line 711: " HTML with M4[J

line 712: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 713: [J

line 714: " HTML Cheetah template[J

line 715: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 716: [J

line 717: " Host config[J

line 718: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf[J

line 719: [J

line 720: " Hosts access[J

line 721: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess[J

line 722: [J

line 723: " Hyper Builder[J

line 724: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 725: [J

line 726: " Httest[J

line 727: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest[J

line 728: [J

line 729: " Icon[J

line 730: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 731: [J

line 732: " IDL (Interface Description Language)[J

line 733: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()[J

line 734: [J

line 735: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 736: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 737: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 738: [J

line 739: " Icewm menu[J

line 740: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 741: [J

line 742: " Indent profile (must come before IDL *.pro!)[J

line 743: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 744: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')[J

line 745: [J

line 746: " IDL (Interactive Data Language)[J

line 747: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')[J

line 748: [J

line 749: " Indent RC[J

line 750: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 751: [J

line 752: " Inform[J

line 753: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 754: [J

line 755: " Initng[J

line 756: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng[J

line 757: [J

line 758: " Innovation Data Processing[J

line 759: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat[J

line 760: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog[J

line 761: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog[J

line 762: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog[J

line 763: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog[J

line 764: [J

line 765: " Ipfilter[J

line 766: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 767: [J

line 768: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 769: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 770: [J

line 771: " .INI file for MSDOS[J

line 772: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 773: [J

line 774: " SysV Inittab[J

line 775: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 776: [J

line 777: " Inno Setup[J

line 778: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 779: [J

line 780: " J[J

line 781: au BufNewFile,BufRead *.ijs^I^I^Isetf j[J

line 782: [J

line 783: " JAL[J

line 784: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 785: [J

line 786: " Jam[J

line 787: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 788: [J

line 789: " Java[J

line 790: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 791: [J

line 792: " JavaCC[J

line 793: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 794: [J

line 795: " JavaScript, ECMAScript[J

line 796: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript[J

line 797: [J

line 798: " Java Server Pages[J

line 799: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 800: [J

line 801: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 802: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 803: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 804: [J

line 805: " Jess[J

line 806: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 807: [J

line 808: " Jgraph[J

line 809: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 810: [J

line 811: " Jovial[J

line 812: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial[J

line 813: [J

line 814: " JSON[J

line 815: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json[J

line 816: [J

line 817: " Kixtart[J

line 818: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 819: [J

line 820: " Kimwitu[++][J

line 821: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 822: [J

line 823: " Kivy[J

line 824: au BufNewFile,BufRead *.kv^I^I^Isetf kivy[J

line 825: [J

line 826: " KDE script[J

line 827: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 828: [J

line 829: " Kconfig[J

line 830: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 831: [J

line 832: " Lace (ISE)[J

line 833: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 834: [J

line 835: " Latte[J

line 836: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 837: [J

line 838: " Limits[J

line 839: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits[J

line 840: [J

line 841: " LambdaProlog (*.mod too, see Modsim)[J

line 842: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 843: [J

line 844: " LDAP LDIF[J

line 845: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 846: [J

line 847: " Ld loader[J

line 848: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 849: [J

line 850: " Less[J

line 851: au BufNewFile,BufRead *.less^I^I^Isetf less[J

line 852: [J

line 853: " Lex[J

line 854: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex[J

line 855: [J

line 856: " Libao[J

line 857: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao[J

line 858: [J

line 859: " Libsensors[J

line 860: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors[J

line 861: [J

line 862: " LFTP[J

line 863: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 864: [J

line 865: " Lifelines (or Lex for C++!)[J

line 866: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 867: [J

line 868: " Lilo: Linux loader[J

line 869: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo[J

line 870: [J

line 871: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 872: if has("fname_case")[J

line 873:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 874: else[J

line 875:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 876: endif[J

line 877: [J

line 878: " SBCL implementation of Common Lisp[J

line 879: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 880: [J

line 881: " Liquid[J

line 882: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 883: [J

line 884: " Lite[J

line 885: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 886: [J

line 887: " LiteStep RC files[J

line 888: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 889: [J

line 890: " Login access[J

line 891: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess[J

line 892: [J

line 893: " Login defs[J

line 894: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs[J

line 895: [J

line 896: " Logtalk[J

line 897: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 898: [J

line 899: " LOTOS[J

line 900: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 901: [J

line 902: " Lout (also: *.lt)[J

line 903: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 904: [J

line 905: " Lua[J

line 906: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 907: [J

line 908: " Luarocks[J

line 909: au BufNewFile,BufRead *.rockspec^I^Isetf lua[J

line 910: [J

line 911: " Linden Scripting Language (Second Life)[J

line 912: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 913: [J

line 914: " Lynx style file (or LotusScript!)[J

line 915: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 916: [J

line 917: " M4[J

line 919: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 920: [J

line 921: " MaGic Point[J

line 922: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 923: [J

line 924: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)[J

line 925: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 926: [J

line 927: " Mail aliases[J

line 928: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases[J

line 929: [J

line 930: " Mailcap configuration file[J

line 931: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 932: [J

line 933: " Makefile[J

line 934: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 935: [J

line 936: " MakeIndex[J

line 937: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 938: [J

line 939: " Mallard[J

line 940: au BufNewFile,BufRead *.page^I^I^Isetf mallard[J

line 941: [J

line 942: " Manpage[J

line 943: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 944: [J

line 945: " Man config[J

line 946: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf[J

line 947: [J

line 948: " Maple V[J

line 949: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 950: [J

line 951: " Map (UMN mapserver config file)[J

line 952: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 953: [J

line 954: " Markdown[J

line 955: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown[J

line 956: [J

line 957: " Mason[J

line 958: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason[J

line 959: [J

line 960: " Mathematica, Matlab, Murphi or Objective C[J

line 961: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()[J

line 962: [J

line 963: " Mathematica notebook[J

line 964: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 965: [J

line 966: " Maya Extension Language[J

line 967: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 968: [J

line 969: " Mercurial (hg) commit file[J

line 970: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit[J

line 971: [J

line 972: " Mercurial config (looks like generic config file)[J

line 973: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 974: [J

line 975: " Messages (logs mostly)[J

line 976: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages[J

line 977: [J

line 978: " Metafont[J

line 979: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 980: [J

line 981: " MetaPost[J

line 982: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 983: [J

line 984: " MGL[J

line 985: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 986: [J

line 987: " MIX - Knuth assembly[J

line 988: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix[J

line 989: [J

line 990: " MMIX or VMS makefile[J

line 991: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()[J

line 992: [J

line 993: " Symbian meta-makefile definition (MMP)[J

line 994: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 995: [J

line 996: " Modsim III (or LambdaProlog)[J

line 1002: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1003: [J

line 1004: " Modula 2  (.md removed in favor of Markdown)[J

line 1005: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2[J

line 1006: [J

line 1007: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1008: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1009: [J

line 1010: " Monk[J

line 1011: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1012: [J

line 1013: " MOO[J

line 1014: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1015: [J

line 1016: " Modconf[J

line 1017: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf[J

line 1018: [J

line 1019: " Mplayer config[J

line 1020: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1021: [J

line 1022: " Motorola S record[J

line 1023: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec[J

line 1024: [J

line 1025: " Mrxvtrc[J

line 1026: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1027: [J

line 1028: " Msql[J

line 1029: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1030: [J

line 1031: " Mysql[J

line 1032: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1033: [J

line 1034: " Mutt setup files (must be before catch *.rc)[J

line 1035: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')[J

line 1036: [J

line 1037: " M$ Resource files[J

line 1038: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc[J

line 1039: [J

line 1040: " MuPAD source[J

line 1041: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1042: [J

line 1043: " Mush[J

line 1044: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1045: [J

line 1046: " Mutt setup file (also for Muttng)[J

line 1047: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1048: [J

line 1049: " N1QL[J

line 1050: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql[J

line 1051: [J

line 1052: " Nano[J

line 1053: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc[J

line 1054: [J

line 1055: " Nastran input/DMAP[J

line 1056: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1057: [J

line 1058: " Natural[J

line 1059: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1060: [J

line 1061: " Noemutt setup file[J

line 1062: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc[J

line 1063: [J

line 1064: " Netrc[J

line 1065: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1066: [J

line 1067: " Ninja file[J

line 1068: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja[J

line 1069: [J

line 1070: " Novell netware batch files[J

line 1071: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1072: [J

line 1073: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1077: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1078: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1079: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()[J

line 1080: [J

line 1081: " Nroff or Objective C++[J

line 1082: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()[J

line 1083: [J

line 1084: " Not Quite C[J

line 1085: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1086: [J

line 1087: " NSE - Nmap Script Engine - uses Lua syntax[J

line 1088: au BufNewFile,BufRead *.nse^I^I^Isetf lua[J

line 1089: [J

line 1090: " NSIS[J

line 1091: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis[J

line 1092: [J

line 1093: " OCAML[J

line 1094: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml[J

line 1095: [J

line 1096: " Occam[J

line 1097: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1098: [J

line 1099: " Omnimark[J

line 1100: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1101: [J

line 1102: " OpenROAD[J

line 1103: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1104: [J

line 1105: " OPL[J

line 1106: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1107: [J

line 1108: " Oracle config file[J

line 1109: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1110: [J

line 1111: " Packet filter conf[J

line 1112: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1113: [J

line 1114: " Pam conf[J

line 1115: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf[J

line 1116: [J

line 1117: " PApp[J

line 1118: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1119: [J

line 1120: " Password file[J

line 1121: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd[J

line 1122: [J

line 1123: " Pascal (also *.p)[J

line 1124: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1125: [J

line 1126: " Delphi project file[J

line 1127: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1128: [J

line 1129: " PDF[J

line 1130: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1131: [J

line 1132: " PCMK - HAE - crm configure edit [J

line 1133: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk[J

line 1134: [J

line 1135: " Perl[J

line 1136: if has("fname_case")[J

line 1137:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()[J

line 1138: else[J

line 1139:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()[J

line 1140: endif[J

line 1141: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl[J

line 1142: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6[J

line 1143: [J

line 1144: " Perl, XPM or XPM2[J

line 1152: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1153: [J

line 1154: " Perl POD[J

line 1155: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1156: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6[J

line 1157: [J

line 1158: " Php, php3, php4, etc.[J

line 1159: " Also Phtml (was used for PHP 2 in the past)[J

line 1160: " Also .ctp for Cake template file[J

line 1161: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1162: [J

line 1163: " Pike and Cmod[J

line 1164: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike[J

line 1165: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod[J

line 1166: [J

line 1167: " Pinfo config[J

line 1168: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1169: [J

line 1170: " Palm Resource compiler[J

line 1171: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1172: [J

line 1173: " Pine config[J

line 1174: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1175: [J

line 1176: " PL/1, PL/I[J

line 1177: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli[J

line 1178: [J

line 1179: " PL/M (also: *.inp)[J

line 1180: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1181: [J

line 1182: " PL/SQL[J

line 1183: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1184: [J

line 1185: " PLP[J

line 1186: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1187: [J

line 1188: " PO and PO template (GNU gettext)[J

line 1189: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1190: [J

line 1191: " Postfix main config[J

line 1192: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1193: [J

line 1194: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1195: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1196: [J

line 1197: " PostScript Printer Description[J

line 1198: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1199: [J

line 1200: " Povray[J

line 1201: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1202: [J

line 1203: " Povray configuration[J

line 1204: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1205: [J

line 1206: " Povray, PHP or assembly[J

line 1207: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()[J

line 1208: [J

line 1209: " Printcap and Termcap[J

line 1211: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1213: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1214: [J

line 1215: " PCCTS / ANTRL[J

line 1216: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1217: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1218: [J

line 1219: " PPWizard[J

line 1220: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1221: [J

line 1222: " Obj 3D file format[J

line 1223: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1224: au BufNewFile,BufRead *.obj^I^I^Isetf obj[J

line 1225: [J

line 1226: " Oracle Pro*C/C++[J

line 1227: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1228: [J

line 1229: " Privoxy actions file[J

line 1230: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1231: [J

line 1232: " Procmail[J

line 1233: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1234: [J

line 1235: " Progress or CWEB[J

line 1236: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()[J

line 1237: [J

line 1238: " Progress or assembly[J

line 1239: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()[J

line 1240: [J

line 1241: " Progress or Pascal[J

line 1242: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()[J

line 1243: [J

line 1244: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1245: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1249: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1250: [J

line 1251: " Prolog[J

line 1252: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1253: [J

line 1254: " Promela[J

line 1255: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1256: [J

line 1257: " Google protocol buffers[J

line 1258: au BufNewFile,BufRead *.proto^I^I^Isetf proto[J

line 1259: [J

line 1260: " Protocols[J

line 1261: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols[J

line 1262: [J

line 1263: " Pyrex[J

line 1264: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1265: [J

line 1266: " Python, Python Shell Startup Files[J

line 1267: " Quixote (Python-based web framework)[J

line 1268: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python[J

line 1269: [J

line 1270: " Radiance[J

line 1271: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1272: [J

line 1273: " Ratpoison config/command files[J

line 1274: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1275: [J

line 1276: " RCS file[J

line 1277: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1278: [J

line 1279: " Readline[J

line 1280: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1281: [J

line 1282: " Registry for MS-Windows[J

line 1284: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1285: [J

line 1286: " Renderman Interface Bytestream[J

line 1287: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1288: [J

line 1289: " Rexx[J

line 1290: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx[J

line 1291: [J

line 1292: " R (Splus)[J

line 1293: if has("fname_case")[J

line 1294:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1295: else[J

line 1296:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1297: endif[J

line 1298: [J

line 1299: " R Help file[J

line 1300: if has("fname_case")[J

line 1301:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1302: else[J

line 1303:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1304: endif[J

line 1305: [J

line 1306: " R noweb file[J

line 1307: if has("fname_case")[J

line 1308:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1309: else[J

line 1310:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1311: endif[J

line 1312: [J

line 1313: " R Markdown file[J

line 1314: if has("fname_case")[J

line 1315:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd[J

line 1316: else[J

line 1317:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd[J

line 1318: endif[J

line 1319: [J

line 1320: " R reStructuredText file[J

line 1321: if has("fname_case")[J

line 1322:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst[J

line 1323: else[J

line 1324:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst[J

line 1325: endif[J

line 1326: [J

line 1327: " Rexx, Rebol or R[J

line 1328: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()[J

line 1329: [J

line 1330: " Remind[J

line 1331: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind[J

line 1332: [J

line 1333: " Resolv.conf[J

line 1334: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1335: [J

line 1336: " Relax NG Compact[J

line 1337: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1338: [J

line 1339: " Relax NG XML[J

line 1340: au BufNewFile,BufRead *.rng^I^I^Isetf rng[J

line 1341: [J

line 1342: " RPL/2[J

line 1343: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1344: [J

line 1345: " Robots.txt[J

line 1346: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1347: [J

line 1348: " Rpcgen[J

line 1349: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1350: [J

line 1351: " reStructuredText Documentation Format[J

line 1352: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1353: [J

line 1354: " RTF[J

line 1355: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1356: [J

line 1357: " Interactive Ruby shell[J

line 1358: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1359: [J

line 1360: " Ruby[J

line 1361: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby[J

line 1362: [J

line 1363: " RubyGems[J

line 1364: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby[J

line 1365: [J

line 1366: " Rust[J

line 1367: au BufNewFile,BufRead *.rs^I^I^Isetf rust[J

line 1368: [J

line 1369: " Rackup[J

line 1370: au BufNewFile,BufRead *.ru^I^I^Isetf ruby[J

line 1371: [J

line 1372: " Bundler[J

line 1373: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby[J

line 1374: [J

line 1375: " Ruby on Rails[J

line 1376: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1377: [J

line 1378: " Rantfile and Rakefile is like Ruby[J

line 1379: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1380: [J

line 1381: " S-lang (or shader language, or SmallLisp)[J

line 1382: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1383: [J

line 1384: " Samba config[J

line 1385: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1386: [J

line 1387: " SAS script[J

line 1388: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1389: [J

line 1390: " Sass[J

line 1391: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1392: [J

line 1393: " Sather[J

line 1394: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1395: [J

line 1396: " Scala[J

line 1397: au BufNewFile,BufRead *.scala^I^I^Isetf scala[J

line 1398: [J

line 1399: " SBT - Scala Build Tool[J

line 1400: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt[J

line 1401: [J

line 1402: " Scilab[J

line 1403: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1404: [J

line 1405: " SCSS[J

line 1406: au BufNewFile,BufRead *.scss^I^I^Isetf scss[J

line 1407: [J

line 1408: " SD: Streaming Descriptors[J

line 1409: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1410: [J

line 1411: " SDL[J

line 1412: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1413: [J

line 1414: " sed[J

line 1415: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1416: [J

line 1417: " Sieve (RFC 3028)[J

line 1418: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1419: [J

line 1420: " Sendmail[J

line 1421: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1422: [J

line 1423: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1424: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()[J

line 1425: [J

line 1426: " Services[J

line 1427: au BufNewFile,BufRead */etc/services^I^Isetf services[J

line 1428: [J

line 1429: " Service Location config[J

line 1430: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf[J

line 1431: [J

line 1432: " Service Location registration[J

line 1433: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg[J

line 1434: [J

line 1435: " Service Location SPI[J

line 1436: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi[J

line 1437: [J

line 1438: " Setserial config[J

line 1439: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial[J

line 1440: [J

line 1441: " SGML[J

line 1451: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif[J

line 1452: [J

line 1453: " SGMLDECL[J

line 1457: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1458: [J

line 1459: " SGML catalog file[J

line 1460: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1461: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1462: [J

line 1463: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1464: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts[J

line 1465: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,PKGBUILD*,*.install,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")[J

line 1466: au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")[J

line 1467: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))[J

line 1468: [J

line 1469: " Shell script (Arch Linux) or PHP file (Drupal)[J

line 1475: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif[J

line 1476: [J

line 1477: " tcsh scripts[J

line 1478: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")[J

line 1479: [J

line 1480: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1481: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()[J

line 1482: [J

line 1483: " Z-Shell script[J

line 1484: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh[J

line 1485: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1486: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh[J

line 1487: [J

line 1488: " Scheme[J

line 1489: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme[J

line 1490: [J

line 1491: " Screen RC[J

line 1492: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1493: [J

line 1494: " Simula[J

line 1495: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1496: [J

line 1497: " SINDA[J

line 1498: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1499: [J

line 1500: " SiSU[J

line 1501: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1502: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1503: [J

line 1504: " SKILL[J

line 1505: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1506: [J

line 1507: " SLRN[J

line 1508: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1509: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1510: [J

line 1511: " Smalltalk (and TeX)[J

line 1512: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1520: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif[J

line 1521: [J

line 1522: " Smarty templates[J

line 1523: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1524: [J

line 1525: " SMIL or XML[J

line 1531: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 1532: [J

line 1533: " SMIL or SNMP MIB file[J

line 1539: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 1540: [J

line 1541: " SMITH[J

line 1542: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 1543: [J

line 1544: " Snobol4 and spitbol[J

line 1545: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 1546: [J

line 1547: " SNMP MIB files[J

line 1548: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 1549: [J

line 1550: " Snort Configuration[J

line 1551: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 1552: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()[J

line 1553: [J

line 1554: " Spec (Linux RPM)[J

line 1555: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 1556: [J

line 1557: " Speedup (AspenTech plant simulator)[J

line 1558: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 1559: [J

line 1560: " Slice[J

line 1561: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 1562: [J

line 1563: " Spice[J

line 1564: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 1565: [J

line 1566: " Spyce[J

line 1567: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 1568: [J

line 1569: " Squid[J

line 1570: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 1571: [J

line 1572: " SQL for Oracle Designer[J

line 1573: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 1574: [J

line 1575: " SQL[J

line 1576: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()[J

line 1577: [J

line 1578: " SQLJ[J

line 1579: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 1580: [J

line 1581: " SQR[J

line 1582: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 1583: [J

line 1584: " OpenSSH configuration[J

line 1585: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 1586: [J

line 1587: " OpenSSH server configuration[J

line 1588: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 1589: [J

line 1590: " Stata[J

line 1591: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata[J

line 1592: " Also *.class, but not when it's a Java bytecode file[J

line 1594: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif[J

line 1595: [J

line 1596: " SMCL[J

line 1597: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 1598: [J

line 1599: " Stored Procedures[J

line 1600: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 1601: [J

line 1602: " Standard ML[J

line 1603: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 1604: [J

line 1605: " Sratus VOS command macro[J

line 1606: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 1607: [J

line 1608: " Sysctl[J

line 1609: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl[J

line 1610: [J

line 1611: " Systemd unit files[J

line 1612: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd[J

line 1613: [J

line 1614: " Synopsys Design Constraints[J

line 1615: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 1616: [J

line 1617: " Sudoers[J

line 1618: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 1619: [J

line 1620: " SVG (Scalable Vector Graphics)[J

line 1621: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 1622: [J

line 1623: " Tads (or Nroff or Perl test file)[J

line 1625: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif[J

line 1626: [J

line 1627: " Tags[J

line 1628: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 1629: [J

line 1630: " TAK[J

line 1631: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 1632: [J

line 1633: " Task[J

line 1634: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 1635: au BufRead,BufNewFile *.task^I^I^Isetf taskedit[J

line 1636: [J

line 1637: " Tcl (JACL too)[J

line 1638: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 1639: [J

line 1640: " TealInfo[J

line 1641: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 1642: [J

line 1643: " Telix Salt[J

line 1644: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 1645: [J

line 1646: " Tera Term Language[J

line 1647: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm[J

line 1648: [J

line 1649: " Terminfo[J

line 1650: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 1651: [J

line 1652: " TeX[J

line 1653: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 1654: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()[J

line 1655: [J

line 1656: " ConTeXt[J

line 1657: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context[J

line 1658: [J

line 1659: " Texinfo[J

line 1660: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 1661: [J

line 1662: " TeX configuration[J

line 1663: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 1664: [J

line 1665: " Tidy config[J

line 1666: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 1667: [J

line 1668: " TF mud client[J

line 1669: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 1670: [J

line 1671: " tmux configuration[J

line 1672: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux[J

line 1673: [J

line 1674: " TPP - Text Presentation Program[J

line 1675: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 1676: [J

line 1677: " Treetop[J

line 1678: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop[J

line 1679: [J

line 1680: " Trustees[J

line 1681: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 1682: [J

line 1683: " TSS - Geometry[J

line 1684: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 1685: [J

line 1686: " TSS - Optics[J

line 1687: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 1688: [J

line 1689: " TSS - Command Line (temporary)[J

line 1690: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 1691: [J

line 1692: " TWIG files[J

line 1693: au BufNewFile,BufReadPost *.twig^I^Isetf twig[J

line 1694: [J

line 1695: " Motif UIT/UIL files[J

line 1696: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 1697: [J

line 1698: " Udev conf[J

line 1699: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf[J

line 1700: [J

line 1701: " Udev permissions[J

line 1702: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm[J

line 1703: "[J

line 1704: " Udev symlinks config[J

line 1705: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh[J

line 1706: [J

line 1707: " UnrealScript[J

line 1708: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 1709: [J

line 1710: " Updatedb[J

line 1711: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb[J

line 1712: [J

line 1713: " Upstart (init(8)) config files[J

line 1714: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart[J

line 1715: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart[J

line 1716: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart[J

line 1717: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart[J

line 1718: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart[J

line 1719: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart[J

line 1720: [J

line 1721: " Vera[J

line 1722: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 1723: [J

line 1724: " Verilog HDL[J

line 1725: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 1726: [J

line 1727: " Verilog-AMS HDL[J

line 1728: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 1729: [J

line 1730: " SystemVerilog[J

line 1731: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog[J

line 1732: [J

line 1733: " VHDL[J

line 1734: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 1735: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 1736: [J

line 1737: " Vim script[J

line 1738: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 1739: [J

line 1740: " Viminfo file[J

line 1741: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 1742: [J

line 1743: " Virata Config Script File or Drupal module[J

line 1749: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 1750: [J

line 1751: " Visual Basic (also uses *.bas) or FORM[J

line 1752: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")[J

line 1753: [J

line 1754: " SaxBasic is close to Visual Basic[J

line 1755: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 1756: [J

line 1757: " Vgrindefs file[J

line 1758: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 1759: [J

line 1760: " VRML V1.0c[J

line 1761: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 1762: [J

line 1763: " Vroom (vim testing and executable documentation)[J

line 1764: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom[J

line 1765: [J

line 1766: " Webmacro[J

line 1767: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 1768: [J

line 1769: " Wget config[J

line 1770: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 1771: [J

line 1772: " Website MetaLanguage[J

line 1773: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 1774: [J

line 1775: " Winbatch[J

line 1776: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 1777: [J

line 1778: " WSML[J

line 1779: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 1780: [J

line 1781: " WPL[J

line 1782: au BufNewFile,BufRead *.wpl^I^I^Isetf xml[J

line 1783: [J

line 1784: " WvDial[J

line 1785: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 1786: [J

line 1787: " CVS RC file[J

line 1788: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 1789: [J

line 1790: " CVS commit file[J

line 1791: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 1792: [J

line 1793: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 1794: " lines in a WEB file).[J

line 1800: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 1801: [J

line 1802: " Windows Scripting Host and Windows Script Component[J

line 1803: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 1804: [J

line 1805: " XHTML[J

line 1806: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 1807: [J

line 1808: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 1814: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 1815: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 1816: [J

line 1817: " XFree86 config[J

line 1822: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf[J

line 1825: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 1826: [J

line 1827: " Xorg config[J

line 1828: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 1829: [J

line 1830: " Xinetd conf[J

line 1831: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd[J

line 1832: [J

line 1833: " XS Perl extension interface language[J

line 1834: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 1835: [J

line 1836: " X resources file[J

line 1837: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 1838: [J

line 1839: " Xmath[J

line 1840: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 1842: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif[J

line 1843: [J

line 1844: " XML  specific variants: docbk and xbl[J

line 1845: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()[J

line 1846: [J

line 1847: " XMI (holding UML models) is also XML[J

line 1848: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 1849: [J

line 1850: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 1851: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 1852: [J

line 1853: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 1854: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 1855: [J

line 1856: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 1857: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 1858: [J

line 1859: " Xdg menus[J

line 1860: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml[J

line 1861: [J

line 1862: " ATI graphics driver configuration[J

line 1863: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 1864: [J

line 1865: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 1866: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 1867: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 1868: [J

line 1869: " XML User Interface Language[J

line 1870: au BufNewFile,BufRead *.xul^I^I^Isetf xml[J

line 1871: [J

line 1872: " X11 xmodmap (also see below)[J

line 1873: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 1874: [J

line 1875: " Xquery[J

line 1876: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 1877: [J

line 1878: " XSD[J

line 1879: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 1880: [J

line 1881: " Xslt[J

line 1882: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 1883: [J

line 1884: " Yacc[J

line 1885: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc[J

line 1886: [J

line 1887: " Yacc or racc[J

line 1888: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()[J

line 1889: [J

line 1890: " Yaml or Raml[J

line 1891: au BufNewFile,BufRead *.yaml,*.yml,*.raml^Isetf yaml[J

line 1892: [J

line 1893: " yum conf (close enough to dosini)[J

line 1894: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini[J

line 1895: [J

line 1896: " Zimbu[J

line 1897: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu[J

line 1898: " Zimbu Templates[J

line 1899: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl[J

line 1900: [J

line 1901: " Zope[J

line 1902: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 1903: "   cpt (zope form controller page template)[J

line 1904: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()[J

line 1905: "   zsql (zope sql method)[J

line 1906: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()[J

line 1907: [J

line 1908: " Z80 assembler asz80[J

line 1909: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 1910: [J

line 1911: augroup END[J

line 1912: [J

line 1913: [J

line 1914: " Source the user-specified filetype file, for backwards compatibility with[J

line 1915: " Vim 5.x.[J

line 1916: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 1917:   execute "source " . myfiletypefile[J

line 1918: endif[J

line 1919: [J

line 1920: [J

line 1921: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 1922: " when there are no matching file name extensions.[J

line 1923: " Don't do this for compressed files.[J

line 1924: augroup filetypedetect[J

line 1927: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 1928: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 1929: [J

line 1930: [J

line 1931: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 1932: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 1933: " script file.[J

line 1934: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 1935: " like are used.[J

line 1936: [J

line 1937: " More Apache style config files[J

line 1938: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')[J

line 1939: [J

line 1940: " More Apache config files[J

line 1941: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')[J

line 1942: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')[J

line 1943: [J

line 1944: " Asterisk config file[J

line 1945: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 1946: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 1947: [J

line 1948: " Bazaar version control[J

line 1949: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 1950: [J

line 1951: " Bazel build file[J

line 1952: if !has("fname_case")[J

line 1953:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl[J

line 1954: endif[J

line 1955: [J

line 1956: " BIND zone[J

line 1957: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 1958: [J

line 1959: " Calendar[J

line 1962: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 1963: [J

line 1964: " Changelog[J

line 1970: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 1971: [J

line 1972: " Crontab[J

line 1973: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 1974: [J

line 1975: " dnsmasq(8) configuration[J

line 1976: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')[J

line 1977: [J

line 1978: " Dracula[J

line 1979: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 1980: [J

line 1981: " Fvwm[J

line 1982: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 1984: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 1990: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 1991: [J

line 1992: " Gedcom[J

line 1993: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 1994: [J

line 1995: " GTK RC[J

line 1996: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 1997: [J

line 1998: " Jam[J

line 1999: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2000: [J

line 2001: " Jargon[J

line 2005: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2006: [J

line 2007: " Kconfig[J

line 2008: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2009: [J

line 2010: " Lilo: Linux loader[J

line 2011: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 2012: [J

line 2013: " Logcheck[J

line 2014: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2015: [J

line 2016: " Makefile[J

line 2017: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2018: [J

line 2019: " Ruby Makefile[J

line 2020: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2021: [J

line 2022: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2023: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail[J

line 2024: [J

line 2025: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')[J

line 2026: [J

line 2027: " Modconf[J

line 2031: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 2032: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2033: [J

line 2034: " Mutt setup file[J

line 2035: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2036: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2037: [J

line 2038: " Neomutt setup file[J

line 2039: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')[J

line 2040: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')[J

line 2041: [J

line 2042: " Nroff macros[J

line 2043: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2044: [J

line 2045: " OpenBSD hostname.if[J

line 2046: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')[J

line 2047: [J

line 2048: " Pam conf[J

line 2049: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2050: [J

line 2051: " Printcap and Termcap[J

line 2055: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2059: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2060: [J

line 2061: " ReDIF[J

line 2062: " Only used when the .rdf file was not detected to be XML.[J

line 2063: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()[J

line 2064: [J

line 2065: " Remind[J

line 2066: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 2067: [J

line 2068: " Vim script[J

line 2069: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2070: [J

line 2071: " Subversion commit file[J

line 2072: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2073: [J

line 2074: " X resources file[J

line 2075: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2076: [J

line 2077: " XFree86 config[J

line 2079: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2084: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2085: [J

line 2086: " X11 xmodmap[J

line 2087: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2088: [J

line 2089: " Xinetd conf[J

line 2090: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2091: [J

line 2092: " yum conf (close enough to dosini)[J

line 2093: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')[J

line 2094: [J

line 2095: " Z-Shell script[J

line 2096: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2097: [J

line 2098: [J

line 2099: " Plain text files, needs to be far down to not override others.  This avoids[J

line 2100: " the "conf" type being used if there is a line starting with '#'.[J

line 2101: au BufNewFile,BufRead *.text,README^I^Isetf text[J

line 2102: [J

line 2103: " Help files match *.txt but should have a last line that is a modeline.[J

line 2107: au BufNewFile,BufRead *.txt^I  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif[J

line 2108: [J

line 2109: [J

line 2110: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2111: " detected filetypes.[J

line 2112: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/ftdetect/*.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/ftdetect/*.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/ftdetect/*.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vim81/ftdetect/*.vim"[J
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/home/connor/.vim/after/ftdetect/*.vim"[J
not found in 'runtimepath': "ftdetect/*.vim"[J
line 2113: [J

line 2114: " NOTE: The above command could have ended the filetypedetect autocmd group[J

line 2115: " and started another one. Let's make sure it has ended to get to a consistent[J

line 2116: " state.[J

line 2117: augroup END[J

line 2118: [J

line 2119: " Generic configuration file. Use FALLBACK, it's just guessing![J

line 2125: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif[J

line 2126: [J

line 2127: [J

line 2128: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2129: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2131: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2132:   source <sfile>:p:h/menu.vim[J

line 2133: endif[J

line 2134: [J

line 2135: " Function called for testing all functions defined here.  These are[J

line 2136: " script-local, thus need to be executed here.[J

line 2137: " Returns a string with error messages (hopefully empty).[J

line 2138: func! TestFiletypeFuncs(testlist)[J

line 2149: [J

line 2150: " Restore 'cpoptions'[J

line 2151: let &cpo = s:cpo_save[J

line 2152: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim81/filetype.vim[J
continuing in /home/connor/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/home/connor/.vim/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/ftplugin.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/ftplugin.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/ftplugin.vim"[J
Searching for "/usr/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/share/vim/vim81/ftplugin.vim"[J
chdir(/usr/share/vim/vim81)[J
fchdir() to previous dir[J
line 7: sourcing "/usr/share/vim/vim81/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_load_ftplugin = 1[J

line 10: [J

line 11: augroup filetypeplugin[J

line 12:   au FileType * call s:LoadFTPlugin()[J

line 13: [J

line 14:   func! s:LoadFTPlugin()[J

line 35: augroup END[J

finished sourcing /usr/share/vim/vim81/ftplugin.vim[J
continuing in /home/connor/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/home/connor/.vim/after/ftplugin.vim"[J
Searching for "indent.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/indent.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/indent.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/indent.vim"[J
Searching for "/usr/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/share/vim/vim81/indent.vim"[J
chdir(/usr/share/vim/vim81)[J
fchdir() to previous dir[J
line 7: sourcing "/usr/share/vim/vim81/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13:   func! s:LoadIndent()[J

line 31: augroup END[J

finished sourcing /usr/share/vim/vim81/indent.vim[J
continuing in /home/connor/.vimrc[J
Searching for "/usr/share/vim/vimfiles/after/indent.vim"[J
Searching for "/home/connor/.vim/after/indent.vim"[J
line 8: [J

line 9: set nocompatible[J

line 10: [J

line 11: set modelines=0[J

line 12: [J

line 13: set tabstop=3[J

line 14: set shiftwidth=3[J

line 15: set softtabstop=3[J

line 16: set expandtab[J

line 17: [J

line 18: set encoding=utf-8[J

line 19: set scrolloff=3[J

line 20: set autoindent[J

line 21: set showmode[J

line 22: set showcmd[J

line 23: set hidden[J

line 24: set wildmenu[J

line 25: set wildmode=list:longest[J

line 26: set visualbell[J

line 27: set cursorline[J

line 28: set ttyfast[J

line 29: set ruler[J

line 30: set backspace=indent,eol,start[J

line 31: set laststatus=2[J

line 32: set relativenumber[J

line 33: set undofile[J

line 34: [J

line 35: let mapleader = ","[J

line 36: [J

line 37: nnoremap / /\v[J

line 38: vnoremap / /\v[J

line 39: set ignorecase[J

line 40: set smartcase[J

line 41: set gdefault[J

line 42: " better searching[J

line 43: set incsearch[J

line 44: set showmatch[J

line 45: set hlsearch[J

line 46: nnoremap <leader><space> :noh<cr>[J

line 47: " tab key to match bracket pairs[J

line 48: nnoremap <tab> %[J

line 49: nnoremap <tab> %[J

line 50: [J

line 51: set wrap[J

line 52: set textwidth=79[J

line 53: set formatoptions=qrn1[J

line 54: " coloured column at line[J

line 55: set colorcolumn=85[J

line 56: [J

line 57: " show invisible characters[J

line 58: set list[J

line 59: set listchars=tab:▸\ ,eol:¬[J

line 60: [J

line 61: " disable arrow keys[J

line 62: nnoremap <up> <nop>[J

line 63: nnoremap <down> <nop>[J

line 64: nnoremap <left> <nop>[J

line 65: nnoremap <right> <nop>[J

line 66: inoremap <up> <nop>[J

line 67: inoremap <down> <nop>[J

line 68: inoremap <left> <nop>[J

line 69: inoremap <right> <nop>[J

line 70: nnoremap j gj[J

line 71: nnoremap k gk[J

line 72: [J

line 73: " map semicolon to colon[J

line 74: nnoremap ; :[J

line 75: [J

line 76: " auto save when tabbing away[J

line 77: au FocusLost * :wa[J

line 78: [J

line 79: " removes all trailing whitspace from file[J

line 80: nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>[J

line 81: [J

line 82: " reselects last pasted line[J

line 83: nnoremap <leader>v V`][J

line 84: [J

line 85: " Open .vimrc in another window[J

line 86: nnoremap <leader>ev <C-w><C-v><C-l>:e $MYVIMRC<cr>[J

line 87: [J

line 88: " faster escaping[J

line 89: inoremap jj <Esc>[J

line 90: [J

line 91: " create new window and change to it[J

line 92: nnoremap <leader>w <C-w><C-w>l[J

line 93: [J

line 94: " easier movement around splits[J

line 95: nnoremap <C-h><C-w>h[J

No mapping found[J
line 96: nnoremap <C-j><C-w>j[J

No mapping found[J
line 97: nnoremap <C-k><C-w>k[J

No mapping found[J
line 98: nnoremap <C-l><C-w>l[J

No mapping found[J
line 99: [J

line 100: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""[J

line 101: [J

line 102: set t_Co=256 " Enables 256 colour vim[J

line 103: [J

line 104: [J

line 105: " Turns on colours[J

line 106: syntax on[J

line 106: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 106: sourcing "/usr/share/vim/vim81/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/syntax/synload.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/syntax/synload.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/syntax/synload.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/syntax/synload.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/share/vim/vim81/syntax/synload.vim"[J
chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/share/vim/vim81/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2016 Nov 04[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim[J
continuing in /usr/share/vim/vim81/syntax/synload.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 61: [J

line 62: [J

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)[J

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 69: [J

line 70: [J

line 71: " Source the user-specified syntax highlighting file[J

line 72: if exists("mysyntaxfile")[J

line 73:   let s:fname = expand(mysyntaxfile)[J

line 74:   if filereadable(s:fname)[J

line 75:     execute "source " . fnameescape(s:fname)[J

line 76:   endif[J

line 77: endif[J

line 78: [J

line 79: " Restore 'cpoptions'[J

line 80: let &cpo = s:cpo_save[J

line 81: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim81/syntax/synload.vim[J
continuing in /usr/share/vim/vim81/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/share/vim/vim81/syntax/syntax.vim[J
continuing in /home/connor/.vimrc[J
line 107: colorscheme dracula[J

Searching for "colors/dracula.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/colors/dracula.vim"[J
chdir(/home/connor/.vim/colors)[J
fchdir() to previous dir[J
line 107: sourcing "/home/connor/.vim/colors/dracula.vim"[J
line 1: " Dracula Theme v1.2.6[J

line 2: "[J

line 3: " https://github.com/zenorocha/dracula-theme[J

line 4: "[J

line 5: " Copyright 2016, All rights reserved[J

line 6: "[J

line 7: " Code licensed under the MIT license[J

line 8: " http://zenorocha.mit-license.org[J

line 9: "[J

line 10: " @author Trevor Heins <@heinst>[J

line 11: " @author Éverton Ribeiro <nuxlli@gmail.com>[J

line 12: " @author Zeno Rocha <hi@zenorocha.com>[J

line 13: [J

line 14: set background=dark[J

Searching for "syntax/syncolor.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 14: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim[J
continuing in /home/connor/.vim/colors/dracula.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/after/syntax/syncolor.vim"[J
line 15: highlight clear[J

Searching for "syntax/syncolor.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 15: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim[J
continuing in /home/connor/.vim/colors/dracula.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/after/syntax/syncolor.vim"[J
line 16: [J

line 17: if exists("syntax_on")[J

line 18:   syntax reset[J

line 18: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/share/vim/vim81/syntax/syncolor.vim"[J
chdir(/usr/share/vim/vim81/syntax)[J
fchdir() to previous dir[J
line 18: sourcing "/usr/share/vim/vim81/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi! link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi! link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi! link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi! link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi! link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi! link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi! link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi! link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi! link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi! link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi! link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi! link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi! link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi! link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi! link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi! link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi! link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi! link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi! link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi! link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi! link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi! link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi! link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi! link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/share/vim/vim81/syntax/syncolor.vim[J
continuing in /home/connor/.vim/colors/dracula.vim[J
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/home/connor/.vim/after/syntax/syncolor.vim"[J
line 19: endif[J

line 20: [J

line 21: let g:colors_name = "dracula"[J

line 22: [J

line 23: hi Cursor ctermfg=17 ctermbg=231 cterm=NONE guifg=#282a36 guibg=#f8f8f0 gui=NONE[J

line 24: hi Visual ctermfg=NONE ctermbg=241 cterm=NONE guifg=NONE guibg=#44475a gui=NONE[J

line 25: hi CursorLine ctermbg=234 cterm=NONE guifg=NONE guibg=#44475a gui=NONE[J

line 26: hi CursorColumn ctermfg=NONE ctermbg=236 cterm=NONE guifg=NONE guibg=#3d3f49 gui=NONE[J

line 27: hi ColorColumn ctermfg=NONE ctermbg=236 cterm=NONE guifg=NONE guibg=#3d3f49 gui=NONE[J

line 28: hi LineNr ctermfg=60 ctermbg=NONE cterm=NONE guifg=#909194 guibg=#282a36 gui=NONE[J

line 29: hi VertSplit ctermfg=231 ctermbg=236 cterm=bold guifg=#64666d guibg=#64666d gui=bold[J

line 30: hi MatchParen ctermfg=212 ctermbg=NONE cterm=underline guifg=#ff79c6 guibg=NONE gui=underline[J

line 31: hi StatusLine ctermfg=231 ctermbg=236 cterm=bold guifg=#f8f8f2 guibg=#64666d gui=bold[J

line 32: hi StatusLineNC ctermfg=231 ctermbg=236 cterm=NONE guifg=#f8f8f2 guibg=#64666d gui=NONE[J

line 33: hi Pmenu ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 34: hi PmenuSel ctermfg=NONE ctermbg=236 cterm=NONE guifg=NONE guibg=#44475a gui=NONE[J

line 35: hi IncSearch ctermfg=17 ctermbg=228 cterm=NONE guifg=#282a36 guibg=#f1fa8c gui=NONE[J

line 36: hi Search ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline[J

line 37: hi Directory ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 38: hi Folded ctermfg=61 ctermbg=235 cterm=NONE guifg=#6272a4 guibg=#282a36 gui=NONE[J

line 39: hi SignColumn ctermfg=246 ctermbg=235 cterm=NONE guifg=#909194 guibg=#44475a gui=NONE[J

line 40: hi FoldColmun ctermfg=246 ctermbg=235 cterm=NONE guifg=#909194 guibg=#44475a gui=NONE[J

line 41: hi Normal guifg=#f8f8f2 guibg=#282a36 gui=NONE[J

line 42: hi Boolean ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 43: hi Character ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 44: hi Comment ctermfg=61 ctermbg=NONE cterm=NONE guifg=#6272a4 guibg=NONE gui=NONE[J

line 45: hi Conditional ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 46: hi Constant ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 47: hi Define ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 48: hi DiffAdd ctermfg=231 ctermbg=64 cterm=bold guifg=#f8f8f2 guibg=#468410 gui=bold[J

line 49: hi DiffDelete ctermfg=88 ctermbg=NONE cterm=NONE guifg=#8b080b guibg=NONE gui=NONE[J

line 50: hi DiffChange ctermfg=231 ctermbg=23 cterm=NONE guifg=#f8f8f2 guibg=#243a5f gui=NONE[J

line 51: hi DiffText ctermfg=231 ctermbg=24 cterm=bold guifg=#f8f8f2 guibg=#204a87 gui=bold[J

line 52: hi ErrorMsg ctermfg=231 ctermbg=212 cterm=NONE guifg=#f8f8f0 guibg=#ff79c6 gui=NONE[J

line 53: hi WarningMsg ctermfg=231 ctermbg=212 cterm=NONE guifg=#f8f8f0 guibg=#ff79c6 gui=NONE[J

line 54: hi Float ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 55: hi Function ctermfg=84 ctermbg=NONE cterm=NONE guifg=#50fa7b guibg=NONE gui=NONE[J

line 56: hi Identifier ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=italic[J

line 57: hi Keyword ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 58: hi Label ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 59: hi NonText ctermfg=231 ctermbg=NONE cterm=NONE guifg=#525563 guibg=#282a36 gui=NONE[J

line 60: hi Number ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 61: hi Operator ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 62: hi PreProc ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 63: hi Special ctermfg=231 ctermbg=NONE cterm=NONE guifg=#f8f8f2 guibg=NONE gui=NONE[J

line 64: hi SpecialKey ctermfg=231 ctermbg=235 cterm=NONE guifg=#525563 guibg=#282a36 gui=NONE[J

line 65: hi Statement ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 66: hi StorageClass ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=italic[J

line 67: hi String ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 68: hi Tag ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 69: hi Title ctermfg=231 ctermbg=NONE cterm=bold guifg=#f8f8f2 guibg=NONE gui=bold[J

line 70: hi Todo ctermfg=61 ctermbg=NONE cterm=inverse,bold guifg=#6272a4 guibg=NONE gui=inverse,bold[J

line 71: hi Type ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 72: hi Underlined ctermfg=NONE ctermbg=NONE cterm=underline guifg=NONE guibg=NONE gui=underline[J

line 73: hi rubyClass ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 74: hi rubyFunction ctermfg=84 ctermbg=NONE cterm=NONE guifg=#50fa7b guibg=NONE gui=NONE[J

line 75: hi rubyInterpolationDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 76: hi rubySymbol ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 77: hi rubyConstant ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic[J

line 78: hi rubyStringDelimiter ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 79: hi rubyBlockParameter ctermfg=215 ctermbg=NONE cterm=NONE guifg=#ffb86c guibg=NONE gui=italic[J

line 80: hi rubyInstanceVariable ctermfg=203 ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 81: hi rubyInclude ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 82: hi rubyGlobalVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 83: hi rubyRegexp ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 84: hi rubyRegexpDelimiter ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 85: hi rubyEscape ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 86: hi rubyControl ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 87: hi rubyClassVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 88: hi rubyOperator ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 89: hi rubyException ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 90: hi rubyPseudoVariable ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 91: hi rubyRailsUserClass ctermfg=81 ctermbg=NONE cterm=NONE guifg=#66d9ef guibg=NONE gui=italic[J

line 92: hi rubyRailsARAssociationMethod ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 93: hi rubyRailsARMethod ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 94: hi rubyRailsRenderMethod ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 95: hi rubyRailsMethod ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 96: hi erubyDelimiter ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 97: hi erubyComment ctermfg=61 ctermbg=NONE cterm=NONE guifg=#6272a4 guibg=NONE gui=NONE[J

line 98: hi erubyRailsMethod ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 99: hi htmlTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 100: hi htmlEndTag ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 101: hi htmlTagName ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 102: hi htmlArg ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 103: hi htmlSpecialChar ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 104: hi javaScriptFunction ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=italic[J

line 105: hi javaScriptRailsFunction ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 106: hi javaScriptBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 107: hi yamlKey ctermfg=212 ctermbg=NONE cterm=NONE guifg=#ff79c6 guibg=NONE gui=NONE[J

line 108: hi yamlAnchor ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 109: hi yamlAlias ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 110: hi yamlDocumentHeader ctermfg=228 ctermbg=NONE cterm=NONE guifg=#f1fa8c guibg=NONE gui=NONE[J

line 111: hi cssURL ctermfg=215 ctermbg=NONE cterm=NONE guifg=#ffb86c guibg=NONE gui=italic[J

line 112: hi cssFunctionName ctermfg=117 ctermbg=NONE cterm=NONE guifg=#8be9fd guibg=NONE gui=NONE[J

line 113: hi cssColor ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 114: hi cssPseudoClassId ctermfg=84 ctermbg=NONE cterm=NONE guifg=#50fa7b guibg=NONE gui=NONE[J

line 115: hi cssClassName ctermfg=84 ctermbg=NONE cterm=NONE guifg=#50fa7b guibg=NONE gui=NONE[J

line 116: hi cssValueLength ctermfg=141 ctermbg=NONE cterm=NONE guifg=#bd93f9 guibg=NONE gui=NONE[J

line 117: hi cssCommonAttr ctermfg=81 ctermbg=NONE cterm=NONE guifg=#6be5fd guibg=NONE gui=NONE[J

line 118: hi cssBraces ctermfg=NONE ctermbg=NONE cterm=NONE guifg=NONE guibg=NONE gui=NONE[J

line 119: hi TabLineFill  guifg=#333333 guibg=#282a36 gui=none[J

line 120: hi TabLine      guifg=#666666 guibg=#282a36 gui=none[J

line 121: hi TabLineSel   guifg=WHITE guibg=#282a36 gui=none[J

line 122: [J

line 123: "-------------------[J

line 124: "[J

line 125: "cygwin has an annoying behavior where it resets background to light[J

line 126: "regardless of what is set above, so we force it yet again[J

line 127: "[J

line 128: "add these to get cygwin shell working when used to ssh into a centos6 vm[J

line 129: "this requires your TERM=xterm-256color in the guest vm[J

line 130: "- one way to do this is to append to /home/vagrant/.bash_profile ala:[J

line 131: "      TERM=xterm-256color[J

line 132: "      export $TERM[J

line 133: [J

line 134: execute "set background=dark"[J

line 134: set background=dark[J

line 135: "-------------------[J

finished sourcing /home/connor/.vim/colors/dracula.vim[J
continuing in /home/connor/.vimrc[J
line 108: [J

line 109: set history=1000 "changes history record value[J

line 110: [J

line 111: "Use < > to move between tabs "[J

line 112: nnoremap > gt[J

line 113: nnoremap < gT[J

finished sourcing $HOME/.vimrc[J
Searching for "pack/*/start/*" in "/home/connor/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/share/vim/vim81/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/home/connor/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "plugin/**/*.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/plugin/**/*.vim"[J
Searching for "/home/connor/.vim/bundle/Vundle.vim/plugin/**/*.vim"[J
Searching for "/home/connor/.vim/bundle/YouCompleteMe/plugin/**/*.vim"[J
chdir(/home/connor/.vim/bundle/YouCompleteMe/plugin)[J
fchdir() to previous dir[J
sourcing "/home/connor/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim"[J
line 1: " Copyright (C) 2011, 2012  Google Inc.[J

line 2: "[J

line 3: " This file is part of YouCompleteMe.[J

line 4: "[J

line 5: " YouCompleteMe is free software: you can redistribute it and/or modify[J

line 6: " it under the terms of the GNU General Public License as published by[J

line 7: " the Free Software Foundation, either version 3 of the License, or[J

line 8: " (at your option) any later version.[J

line 9: "[J

line 10: " YouCompleteMe is distributed in the hope that it will be useful,[J

line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of[J

line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the[J

line 13: " GNU General Public License for more details.[J

line 14: "[J

line 15: " You should have received a copy of the GNU General Public License[J

line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.[J

line 17: [J

line 18: " This is basic vim plugin boilerplate[J

line 19: let s:save_cpo = &cpo[J

line 20: set cpo&vim[J

line 21: [J

line 22: function! s:restore_cpo()[J

line 26: [J

line 27: if exists( "g:loaded_youcompleteme" )[J

line 28:   call s:restore_cpo()[J

line 29:   finish[J

line 30: elseif v:version < 703 || (v:version == 703 && !has('patch598'))[J

line 33:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim 7.3.598+" | echohl None[J

line 33:  echomsg "YouCompleteMe unavailable: requires Vim 7.3.598+" | echohl None[J

line 33:  echohl None[J

line 34:   call s:restore_cpo()[J

line 35:   finish[J

line 36: elseif !has( 'python' ) && !has( 'python3' )[J

line 40:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (2.6+ or 3.3+) support" | echohl None[J

line 40:  echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (2.6+ or 3.3+) support" | echohl None[J

line 40:  echohl None[J

line 41:   call s:restore_cpo()[J

line 42:   finish[J

line 43: endif[J

line 44: [J

line 45: let g:loaded_youcompleteme = 1[J

line 46: [J

line 47: " NOTE: Most defaults are in third_party/ycmd/ycmd/default_settings.json. They[J

line 48: " are loaded into Vim globals with the 'ycm_' prefix if such a key does not[J

line 49: " already exist; thus, the user can override the defaults.[J

line 50: " The only defaults that are here are the ones that are only relevant to the YCM[J

line 51: " Vim client and not the ycmd server.[J

line 52: [J

line 54: let g:ycm_allow_changing_updatetime = get( g:, 'ycm_allow_changing_updatetime', 1 )[J

line 55: [J

line 57: let g:ycm_open_loclist_on_ycm_diags = get( g:, 'ycm_open_loclist_on_ycm_diags', 1 )[J

line 58: [J

line 60: let g:ycm_add_preview_to_completeopt = get( g:, 'ycm_add_preview_to_completeopt', 0 )[J

line 61: [J

line 63: let g:ycm_autoclose_preview_window_after_completion = get( g:, 'ycm_autoclose_preview_window_after_completion', 0 )[J

line 64: [J

line 66: let g:ycm_autoclose_preview_window_after_insertion = get( g:, 'ycm_autoclose_preview_window_after_insertion', 0 )[J

line 67: [J

line 69: let g:ycm_key_list_select_completion = get( g:, 'ycm_key_list_select_completion', ['<TAB>', '<Down>'] )[J

line 70: [J

line 72: let g:ycm_key_list_previous_completion = get( g:, 'ycm_key_list_previous_completion', ['<S-TAB>', '<Up>'] )[J

line 73: [J

line 75: let g:ycm_key_invoke_completion = get( g:, 'ycm_key_invoke_completion', '<C-Space>' )[J

line 76: [J

line 78: let g:ycm_key_detailed_diagnostics = get( g:, 'ycm_key_detailed_diagnostics', '<leader>d' )[J

line 79: [J

line 81: let g:ycm_cache_omnifunc = get( g:, 'ycm_cache_omnifunc', 1 )[J

line 82: [J

line 84: let g:ycm_server_log_level = get( g:, 'ycm_server_log_level', 'info' )[J

line 85: [J

line 87: let g:ycm_server_keep_logfiles = get( g:, 'ycm_server_keep_logfiles', 0 )[J

line 88: [J

line 90: let g:ycm_extra_conf_vim_data = get( g:, 'ycm_extra_conf_vim_data', [] )[J

line 91: [J

line 94: let g:ycm_server_python_interpreter = get( g:, 'ycm_server_python_interpreter', get( g:, 'ycm_path_to_python_interpreter', '' ) )[J

line 95: [J

line 98: let g:ycm_show_diagnostics_ui = get( g:, 'ycm_show_diagnostics_ui', get( g:, 'ycm_register_as_syntastic_checker', 1 ) )[J

line 99: [J

line 102: let g:ycm_enable_diagnostic_signs = get( g:, 'ycm_enable_diagnostic_signs', get( g:, 'syntastic_enable_signs', 1 ) )[J

line 103: [J

line 106: let g:ycm_enable_diagnostic_highlighting = get( g:, 'ycm_enable_diagnostic_highlighting', get( g:, 'syntastic_enable_highlighting', 1 ) )[J

line 107: [J

line 110: let g:ycm_echo_current_diagnostic = get( g:, 'ycm_echo_current_diagnostic', get( g:, 'syntastic_echo_current_error', 1 ) )[J

line 111: [J

line 114: let g:ycm_always_populate_location_list = get( g:, 'ycm_always_populate_location_list', get( g:, 'syntastic_always_populate_loc_list', 0 ) )[J

line 115: [J

line 118: let g:ycm_error_symbol = get( g:, 'ycm_error_symbol', get( g:, 'syntastic_error_symbol', '>>' ) )[J

line 119: [J

line 122: let g:ycm_warning_symbol = get( g:, 'ycm_warning_symbol', get( g:, 'syntastic_warning_symbol', '>>' ) )[J

line 123: [J

line 125: let g:ycm_goto_buffer_command = get( g:, 'ycm_goto_buffer_command', 'same-buffer' )[J

line 126: [J

line 128: let g:ycm_disable_for_files_larger_than_kb = get( g:, 'ycm_disable_for_files_larger_than_kb', 1000 )[J

line 129: [J

line 130: " On-demand loading. Let's use the autoload folder and not slow down vim's[J

line 131: " startup procedure.[J

line 132: if has( 'vim_starting' ) " loading at startup[J

line 133:   augroup youcompletemeStart[J

line 134:     autocmd![J

line 135:     autocmd VimEnter * call youcompleteme#Enable()[J

line 136:   augroup END[J

line 137: else " manual loading with :packadd[J

line 138:   call youcompleteme#Enable()[J

line 139: endif[J

line 140: [J

line 141: " This is basic vim plugin boilerplate[J

line 142: call s:restore_cpo()[J

calling function <SNR>13_restore_cpo[J()

line 1:   let &cpo = s:save_cpo[J

line 2:   unlet s:save_cpo[J

function <SNR>13_restore_cpo returning #0[J

continuing in /home/connor/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim[J

finished sourcing /home/connor/.vim/bundle/YouCompleteMe/plugin/youcompleteme.vim[J
Searching for "/home/connor/.vim/bundle/nerdcommenter/plugin/**/*.vim"[J
chdir(/home/connor/.vim/bundle/nerdcommenter/plugin)[J
fchdir() to previous dir[J
sourcing "/home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_commenter.vim[J

line 3: " Description: vim global plugin that provides easy code commenting[J

line 4: " Author:      Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Maintainer:  Caleb Maclennan <caleb@alerque.com>[J

line 6: " Version:     2.4.0[J

line 7: " Last Change: Tue May 24 14:03:29 EEST 2016[J

line 8: " License:     This program is free software. It comes without any warranty,[J

line 9: "              to the extent permitted by applicable law. You can redistribute[J

line 10: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 11: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 12: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 13: "[J

line 14: " ============================================================================[J

line 15: [J

line 16: " Section: script init stuff {{{1[J

line 17: if exists("loaded_nerd_comments")[J

line 18:     finish[J

line 19: endif[J

line 20: if v:version < 700[J

line 21:     echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 22:     finish[J

line 23: endif[J

line 24: let loaded_nerd_comments = 1[J

line 25: [J

line 26: " Function: s:InitVariable() function {{{2[J

line 27: " This function is used to initialise a given variable to a given value. The[J

line 28: " variable is only initialised if it does not exist prior[J

line 29: "[J

line 30: " Args:[J

line 31: "   -var: the name of the var to be initialised[J

line 32: "   -value: the value to initialise var to[J

line 33: "[J

line 34: " Returns:[J

line 35: "   1 if the var is set, 0 otherwise[J

line 36: function s:InitVariable(var, value)[J

line 43: [J

line 44: " Section: space string init{{{2[J

line 45: " When putting spaces after the left delimiter and before the right we use[J

line 46: " s:spaceStr for the space char. This way we can make it add anything after[J

line 47: " the left and before the right by modifying this variable[J

line 48: let s:spaceStr = ' '[J

line 49: let s:lenSpaceStr = strlen(s:spaceStr)[J

line 50: [J

line 51: " Section: variable initialization {{{2[J

line 52: call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)[J

calling function <SNR>14_InitVariable[J('g:NERDAllowAnyVisualDelims', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDAllowAnyVisualDelims = '1'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 53: call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDBlockComIgnoreEmpty', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDBlockComIgnoreEmpty = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 54: call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDCommentWholeLinesInVMode', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCommentWholeLinesInVMode = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 55: call s:InitVariable("g:NERDCommentEmptyLines", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDCommentEmptyLines', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCommentEmptyLines = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 56: call s:InitVariable("g:NERDCompactSexyComs", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDCompactSexyComs', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCompactSexyComs = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 57: call s:InitVariable("g:NERDCreateDefaultMappings", 1)[J

calling function <SNR>14_InitVariable[J('g:NERDCreateDefaultMappings', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDCreateDefaultMappings = '1'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 58: call s:InitVariable("g:NERDDefaultNesting", 1)[J

calling function <SNR>14_InitVariable[J('g:NERDDefaultNesting', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDefaultNesting = '1'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 59: call s:InitVariable("g:NERDMenuMode", 3)[J

calling function <SNR>14_InitVariable[J('g:NERDMenuMode', 3)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDMenuMode = '3'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 60: call s:InitVariable("g:NERDLPlace", "[>")[J

calling function <SNR>14_InitVariable[J('g:NERDLPlace', '[>')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDLPlace = '[>'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 61: call s:InitVariable("g:NERDUsePlaceHolders", 1)[J

calling function <SNR>14_InitVariable[J('g:NERDUsePlaceHolders', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDUsePlaceHolders = '1'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 62: call s:InitVariable("g:NERDRemoveAltComs", 1)[J

calling function <SNR>14_InitVariable[J('g:NERDRemoveAltComs', 1)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveAltComs = '1'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 63: call s:InitVariable("g:NERDRemoveExtraSpaces", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDRemoveExtraSpaces', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRemoveExtraSpaces = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 64: call s:InitVariable("g:NERDRPlace", "<]")[J

calling function <SNR>14_InitVariable[J('g:NERDRPlace', '<]')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDRPlace = '<]'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 65: call s:InitVariable("g:NERDSpaceDelims", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDSpaceDelims', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDSpaceDelims = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 66: call s:InitVariable("g:NERDDefaultAlign", "none")[J

calling function <SNR>14_InitVariable[J('g:NERDDefaultAlign', 'none')

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDDefaultAlign = 'none'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 67: call s:InitVariable("g:NERDTrimTrailingWhitespace", 0)[J

calling function <SNR>14_InitVariable[J('g:NERDTrimTrailingWhitespace', 0)

line 1:     if !exists(a:var)[J

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"[J

line 2: let g:NERDTrimTrailingWhitespace = '0'[J

line 3:         return 1[J

function <SNR>14_InitVariable returning #1[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 68: [J

line 69: let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"[J

line 70: [J

line 457: let s:delimiterMap = { 'aap': { 'left': '#' }, 'abc': { 'left': '%' }, 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'ada': { 'left': '--', 'leftAlt': '--  ' }, 'ahdl': { 'left': '--' }, 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' }, 'amiga': { 'left': ';' }, 'aml': { 'left': '/*' }, 'ampl': { 'left': '#' }, 'apache': { 'left': '#' }, 'apachestyle': { 'left': '#' }, 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' }, 'armasm': { 'left': ';' }, 'asciidoc': { 'left': '//' }, 'asm': { 'left': ';', 'leftAlt': '#' }, 'asm68k': { 'left': ';' }, 'asn': { 'left': '--' }, 'asp': { 'left': '%', 'leftAlt': '%*','rightAlt': '*%' }, 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' }, 'asterisk': { 'left': ';' }, 'asy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'atlas': { 'left': 'C', 'right': '$' }, 'autohotkey': { 'left': ';' }, 'autoit': { 'left': ';' }, 'ave': { 'left': "'"[J

line 458: [J

line 459: let g:NERDDelimiterMap = s:delimiterMap[J

line 460: [J

line 461: if exists("g:NERDCustomDelimiters")[J

line 462:     call extend(s:delimiterMap, g:NERDCustomDelimiters)[J

line 463: endif[J

line 464: [J

line 465: " Section: Comment mapping functions, autocommands and commands {{{1[J

line 466: " ============================================================================[J

line 467: " Section: Comment enabler autocommands {{{2[J

line 468: " ============================================================================[J

line 469: [J

line 470: augroup NERDCommenter[J

line 471: [J

line 472:     "if the user enters a buffer or reads a buffer then we gotta set up[J

line 473:     "the comment delimiters for that new filetype[J

line 474:     autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)[J

line 475: [J

line 476:     "if the filetype of a buffer changes, force the script to reset the[J

line 477:     "delimiters for the buffer[J

line 478:     autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)[J

line 479: augroup END[J

line 480: [J

line 481: [J

line 482: " Function: s:SetUpForNewFiletype(filetype) function {{{2[J

line 483: " This function is responsible for setting up buffer scoped variables for the[J

line 484: " given filetype.[J

line 485: "[J

line 486: " Args:[J

line 487: "   -filetype: the filetype to set delimiters for[J

line 488: "   -forceReset: 1 if the delimiters should be reset if they have already be[J

line 489: "    set for this buffer.[J

line 490: "[J

line 491: function s:SetUpForNewFiletype(filetype, forceReset)[J

line 531: [J

line 532: function s:CreateDelimMapFromCms()[J

line 550: [J

line 551: " Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2[J

line 552: " This function is used to swap the delimiters that are being used to the[J

line 553: " alternative delimiters for that filetype. For example, if a c++ file is[J

line 554: " being edited and // comments are being used, after this function is called[J

line 555: " /**/ comments will be used.[J

line 556: "[J

line 557: " Args:[J

line 558: "   -printMsgs: if this is 1 then a message is echoed to the user telling them[J

line 559: "    if this function changed the delimiters or not[J

line 560: function s:SwitchToAlternativeDelimiters(printMsgs)[J

line 600: [J

line 601: " Section: Comment delimiter add/removal functions {{{1[J

line 602: " ============================================================================[J

line 603: " Function: s:AppendCommentToLine(){{{2[J

line 604: " This function appends comment delimiters at the EOL and places the cursor in[J

line 605: " position to start typing the comment[J

line 606: function s:AppendCommentToLine()[J

line 630: [J

line 631: " Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2[J

line 632: " This function is used to comment out a region of code. This region is[J

line 633: " specified as a bounding box by arguments to the function.[J

line 634: "[J

line 635: " Args:[J

line 636: "   -top: the line number for the top line of code in the region[J

line 637: "   -bottom: the line number for the bottom line of code in the region[J

line 638: "   -lSide: the column number for the left most column in the region[J

line 639: "   -rSide: the column number for the right most column in the region[J

line 640: "   -forceNested: a flag indicating whether comments should be nested[J

line 641: function s:CommentBlock(top, bottom, lSide, rSide, forceNested )[J

line 764: [J

line 765: " Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2[J

line 766: " This function comments a range of lines.[J

line 767: "[J

line 768: " Args:[J

line 769: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 770: "    to be nested if need be[J

line 771: "   -align: should be "left", "start", "both" or "none"[J

line 772: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 773: function s:CommentLines(forceNested, align, firstLine, lastLine)[J

line 833: [J

line 834: " Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2[J

line 835: " This function comments a range of lines in a minimal style. I[J

line 836: "[J

line 837: " Args:[J

line 838: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 839: function s:CommentLinesMinimal(firstLine, lastLine)[J

line 894: [J

line 895: " Function: s:CommentLinesSexy(topline, bottomline) function {{{2[J

line 896: " This function is used to comment lines in the 'Sexy' style. E.g., in c:[J

line 897: " /*[J

line 898: "  * This is a sexy comment[J

line 899: "  */[J

line 900: " Args:[J

line 901: "   -topline: the line number of the top line in the sexy comment[J

line 902: "   -bottomline: the line number of the bottom line in the sexy comment[J

line 903: function s:CommentLinesSexy(topline, bottomline)[J

line 1021: [J

line 1022: " Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2[J

line 1023: " Applies "toggle" commenting to the given range of lines[J

line 1024: "[J

line 1025: " Args:[J

line 1026: "   -forceNested: a flag indicating whether the called is requesting the comment[J

line 1027: "    to be nested if need be[J

line 1028: "   -firstLine/lastLine: the top and bottom lines to comment[J

line 1029: function s:CommentLinesToggle(forceNested, firstLine, lastLine)[J

line 1078: [J

line 1079: " Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2[J

line 1080: " This function comments chunks of text selected in visual mode.[J

line 1081: " It will comment exactly the text that they have selected.[J

line 1082: " Args:[J

line 1083: "   -topLine: the line number of the top line in the sexy comment[J

line 1084: "   -topCol: top left column for this comment[J

line 1085: "   -bottomline: the line number of the bottom line in the sexy comment[J

line 1086: "   -bottomCol: the bottom right column for this comment[J

line 1087: "   -forceNested: whether the caller wants comments to be nested if the[J

line 1088: "    line(s) are already commented[J

line 1089: function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)[J

line 1130: [J

line 1131: " Function: s:InvertComment(firstLine, lastLine) function {{{2[J

line 1132: " Inverts the comments on the lines between and including the given line[J

line 1133: " numbers i.e all commented lines are uncommented and vice versa[J

line 1134: " Args:[J

line 1135: "   -firstLine: the top of the range of lines to be inverted[J

line 1136: "   -lastLine: the bottom of the range of lines to be inverted[J

line 1137: function s:InvertComment(firstLine, lastLine)[J

line 1168: [J

line 1169: function! NERDCommentIsLineCommented(lineNo)[J

line 1173: [J

line 1174: " Function: NERDComment(mode, type) function {{{2[J

line 1175: " This function is a Wrapper for the main commenting functions[J

line 1176: "[J

line 1177: " Args:[J

line 1178: "   -mode: a character indicating the mode in which the comment is requested:[J

line 1179: "   'n' for Normal mode, 'x' for Visual mode[J

line 1180: "   -type: the type of commenting requested. Can be 'Sexy', 'Invert',[J

line 1181: "    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',[J

line 1182: "    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'[J

line 1183: function! NERDComment(mode, type) range[J

line 1298: [J

line 1299: " Function: s:PlaceDelimitersAndInsBetween() function {{{2[J

line 1300: " This is function is called to place comment delimiters down and place the[J

line 1301: " cursor between them[J

line 1302: function s:PlaceDelimitersAndInsBetween()[J

line 1349: [J

line 1350: " Function: s:RemoveDelimiters(left, right, line) {{{2[J

line 1351: " this function is called to remove the first left comment delimiter and the[J

line 1352: " last right delimiter of the given line.[J

line 1353: "[J

line 1354: " The arguments left and right must be strings. If there is no right delimiter (as[J

line 1355: " is the case for e.g vim file comments) them the argument right should be ""[J

line 1356: "[J

line 1357: " Args:[J

line 1358: "   -left: the left comment delimiter[J

line 1359: "   -right: the right comment delimiter[J

line 1360: "   -line: the line to remove the delimiters from[J

line 1361: function s:RemoveDelimiters(left, right, line)[J

line 1398: [J

line 1399: " Function: s:SetupStateBeforeLineComment(topLine, bottomLine) {{{2[J

line 1400: " Changes ignorecase and foldmethod options before commenting lines and saves[J

line 1401: " their original values in a dict, which is returned as a result[J

line 1402: "[J

line 1403: " Args:[J

line 1404: " topLine: the top line of the visual selection to uncomment[J

line 1405: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1406: "[J

line 1407: " Return: a dict with the state prior to configuration changes[J

line 1408: "[J

line 1409: function s:SetupStateBeforeLineComment(topLine, bottomLine)[J

line 1427: [J

line 1428: " Function: s:RecoverStateAfterLineComment(state) {{{2[J

line 1429: " Receives the state returned by s:SetupStateBeforeLineComment and restores[J

line 1430: " the state accordingly[J

line 1431: "[J

line 1432: " Args:[J

line 1433: " state: the top line of the visual selection to uncomment[J

line 1434: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1435: function s:RecoverStateAfterLineComment(state)[J

line 1443: [J

line 1444: " Function: s:TrimTrailingWhitespace(line) {{{2[J

line 1445: " This function removes all the trailing whitespace[J

line 1446: " Args:[J

line 1447: "   -line: the target line[J

line 1448: function s:TrimTrailingWhitespace(line)[J

line 1452: [J

line 1453: " Function: s:UncommentLines(topLine, bottomLine) {{{2[J

line 1454: " This function uncomments the given lines[J

line 1455: "[J

line 1456: " Args:[J

line 1457: " topLine: the top line of the visual selection to uncomment[J

line 1458: " bottomLine: the bottom line of the visual selection to uncomment[J

line 1459: function s:UncommentLines(topLine, bottomLine)[J

line 1498: [J

line 1499: " Function: s:UncommentLinesSexy(topline, bottomline) {{{2[J

line 1500: " This function removes all the comment characters associated with the sexy[J

line 1501: " comment spanning the given lines[J

line 1502: " Args:[J

line 1503: "   -topline/bottomline: the top/bottom lines of the sexy comment[J

line 1504: function s:UncommentLinesSexy(topline, bottomline)[J

line 1619: [J

line 1620: " Function: s:UncommentLineNormal(line) {{{2[J

line 1621: " uncomments the given line and returns the result[J

line 1622: " Args:[J

line 1623: "   -line: the line to uncomment[J

line 1624: function s:UncommentLineNormal(line)[J

line 1696: [J

line 1697: " Function: s:UncommentLinesNormal(topline, bottomline) {{{2[J

line 1698: " This function is called to uncomment lines that aren't a sexy comment[J

line 1699: " Args:[J

line 1700: "   -topline/bottomline: the top/bottom line numbers of the comment[J

line 1701: function s:UncommentLinesNormal(topline, bottomline)[J

line 1709: [J

line 1710: [J

line 1711: " Section: Other helper functions {{{1[J

line 1712: " ============================================================================[J

line 1713: [J

line 1714: " Function: s:AddLeftDelim(delim, theLine) {{{2[J

line 1715: " Args:[J

line 1716: function s:AddLeftDelim(delim, theLine)[J

line 1719: [J

line 1720: " Function: s:AddLeftDelimAligned(delim, theLine) {{{2[J

line 1721: " Args:[J

line 1722: function s:AddLeftDelimAligned(delim, theLine, alignIndx)[J

line 1733: [J

line 1734: " Function: s:AddRightDelim(delim, theLine) {{{2[J

line 1735: " Args:[J

line 1736: function s:AddRightDelim(delim, theLine)[J

line 1743: [J

line 1744: " Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2[J

line 1745: " Args:[J

line 1746: function s:AddRightDelimAligned(delim, theLine, alignIndx)[J

line 1761: [J

line 1762: " Function: s:AltMultipart() {{{2[J

line 1763: " returns 1 if the alternative delimiters are multipart[J

line 1764: function s:AltMultipart()[J

line 1767: [J

line 1768: " Function: s:AltNested() {{{2[J

line 1769: " returns 1 if the alternate multipart (if any) delimiters allow nesting[J

line 1770: function s:AltNested()[J

line 1773: [J

line 1774: " Function: s:CanCommentLine(forceNested, line) {{{2[J

line 1775: "This function is used to determine whether the given line can be commented.[J

line 1776: "It returns 1 if it can be and 0 otherwise[J

line 1777: "[J

line 1778: " Args:[J

line 1779: "   -forceNested: a flag indicating whether the caller wants comments to be nested[J

line 1780: "    if the current line is already commented[J

line 1781: "   -lineNum: the line number of the line to check for commentability[J

line 1782: function s:CanCommentLine(forceNested, lineNum)[J

line 1810: [J

line 1811: " Function: s:CanPlaceCursor(line, col) {{{2[J

line 1812: " returns 1 if the cursor can be placed exactly in the given position[J

line 1813: function s:CanPlaceCursor(line, col)[J

line 1821: [J

line 1822: " Function: s:CanSexyCommentLines(topline, bottomline) {{{2[J

line 1823: " Return: 1 if the given lines can be commented sexually, 0 otherwise[J

line 1824: function s:CanSexyCommentLines(topline, bottomline)[J

line 1840: " Function: s:CanToggleCommentLine(forceNested, line) {{{2[J

line 1841: "This function is used to determine whether the given line can be toggle commented.[J

line 1842: "It returns 1 if it can be and 0 otherwise[J

line 1843: "[J

line 1844: " Args:[J

line 1845: "   -lineNum: the line number of the line to check for commentability[J

line 1846: function s:CanToggleCommentLine(forceNested, lineNum)[J

line 1865: [J

line 1866: " Function: s:ConvertLeadingSpacesToTabs(line) {{{2[J

line 1867: " This function takes a line and converts all leading tabs on that line into[J

line 1868: " spaces[J

line 1869: "[J

line 1870: " Args:[J

line 1871: "   -line: the line whose leading tabs will be converted[J

line 1872: function s:ConvertLeadingSpacesToTabs(line)[J

line 1880: [J

line 1881: [J

line 1882: " Function: s:ConvertLeadingTabsToSpaces(line) {{{2[J

line 1883: " This function takes a line and converts all leading spaces on that line into[J

line 1884: " tabs[J

line 1885: "[J

line 1886: " Args:[J

line 1887: "   -line: the line whose leading spaces will be converted[J

line 1888: function s:ConvertLeadingTabsToSpaces(line)[J

line 1896: [J

line 1897: " Function: s:ConvertLeadingWhiteSpace(line) {{{2[J

line 1898: " Converts the leading white space to tabs/spaces depending on &ts[J

line 1899: "[J

line 1900: " Args:[J

line 1901: "   -line: the line to convert[J

line 1902: function s:ConvertLeadingWhiteSpace(line)[J

line 1914: [J

line 1915: [J

line 1916: " Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2[J

line 1917: " This function counts the number of substrings contained in another string.[J

line 1918: " These substrings are only counted if they are not escaped with escChar[J

line 1919: " Args:[J

line 1920: "   -str: the string to look for searchstr in[J

line 1921: "   -searchstr: the substring to search for in str[J

line 1922: "   -escChar: the escape character which, when preceding an instance of[J

line 1923: "    searchstr, will cause it not to be counted[J

line 1924: function s:CountNonESCedOccurances(str, searchstr, escChar)[J

line 1943: " Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2[J

line 1944: " Returns 1 if the given block of lines has a delimiter (a:delim) in it[J

line 1945: " Args:[J

line 1946: "   -delim: the comment delimiter to check the block for[J

line 1947: "   -top: the top line number of the block[J

line 1948: "   -bottom: the bottom line number of the block[J

line 1949: function s:DoesBlockHaveDelim(delim, top, bottom)[J

line 1960: [J

line 1961: " Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2[J

line 1962: " Returns 1 if the given block has a >= 1 multipart delimiter in it[J

line 1963: " Args:[J

line 1964: "   -top: the top line number of the block[J

line 1965: "   -bottom: the bottom line number of the block[J

line 1966: function s:DoesBlockHaveMultipartDelim(top, bottom)[J

line 1976: [J

line 1977: [J

line 1978: " Function: s:Esc(str) {{{2[J

line 1979: " Escapes all the tricky chars in the given string[J

line 1980: function s:Esc(str)[J

line 1984: [J

line 1985: " Function: s:FindDelimiterIndex(delimiter, line) {{{2[J

line 1986: " This function is used to get the string index of the input comment delimiter[J

line 1987: " on the input line. If no valid comment delimiter is found in the line then[J

line 1988: " -1 is returned[J

line 1989: " Args:[J

line 1990: "   -delimiter: the delimiter we are looking to find the index of[J

line 1991: "   -line: the line we are looking for delimiter on[J

line 1992: function s:FindDelimiterIndex(delimiter, line)[J

line 2037: [J

line 2038: " Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2[J

line 2039: " This function takes in a line number and tests whether this line number is[J

line 2040: " the top/bottom/middle line of a sexy comment. If it is then the top/bottom[J

line 2041: " lines of the sexy comment are returned[J

line 2042: " Args:[J

line 2043: "   -lineNum: the line number that is to be tested whether it is the[J

line 2044: "    top/bottom/middle line of a sexy com[J

line 2045: " Returns:[J

line 2046: "   A string that has the top/bottom lines of the sexy comment encoded in it.[J

line 2047: "   The format is 'topline,bottomline'. If a:lineNum turns out not to be the[J

line 2048: "   top/bottom/middle of a sexy comment then -1 is returned[J

line 2049: function s:FindBoundingLinesOfSexyCom(lineNum)[J

line 2111: [J

line 2112: [J

line 2113: " Function: s:GetSexyComMarker() {{{2[J

line 2114: " Returns the sexy comment marker for the current filetype.[J

line 2115: "[J

line 2116: " C style sexy comments are assumed if possible. If not then the sexy comment[J

line 2117: " marker is the last char of the delimiter pair that has both left and right[J

line 2118: " delimiters and has the longest left delimiter[J

line 2119: "[J

line 2120: " Args:[J

line 2121: "   -space: specifies whether the marker is to have a space string after it[J

line 2122: "    (the space string will only be added if NERDSpaceDelims is set)[J

line 2123: "   -esc: specifies whether the tricky chars in the marker are to be ESCed[J

line 2124: function s:GetSexyComMarker(space, esc)[J

line 2164: [J

line 2165: " Function: s:SexyNested() {{{2[J

line 2166: " Returns 1 if the sexy delimeters allow nesting[J

line 2167: " TODO this is ugly copy&paste from the GetSexyComLeft/Right functions,[J

line 2168: " these could all be cleaned up[J

line 2169: function s:SexyNested()[J

line 2187: [J

line 2188: " Function: s:GetSexyComLeft(space, esc) {{{2[J

line 2189: " Returns the left delimiter for sexy comments for this filetype or -1 if[J

line 2190: " there is none. C style sexy comments are used if possible[J

line 2191: " Args:[J

line 2192: "   -space: specifies if the delimiter has a space string on the end[J

line 2193: "   (the space string will only be added if NERDSpaceDelims is set)[J

line 2194: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 2195: function s:GetSexyComLeft(space, esc)[J

line 2224: [J

line 2225: " Function: s:GetSexyComRight(space, esc) {{{2[J

line 2226: " Returns the right delimiter for sexy comments for this filetype or -1 if[J

line 2227: " there is none. C style sexy comments are used if possible.[J

line 2228: " Args:[J

line 2229: "   -space: specifies if the delimiter has a space string on the start[J

line 2230: "   (the space string will only be added if NERDSpaceDelims[J

line 2231: "   is specified for the current filetype)[J

line 2232: "   -esc: specifies whether the tricky chars in the string are ESCed[J

line 2233: function s:GetSexyComRight(space, esc)[J

line 2262: [J

line 2263: " Function: s:HasMultipartDelims() {{{2[J

line 2264: " Returns 1 if the current filetype has at least one set of multipart delimiters[J

line 2265: function s:HasMultipartDelims()[J

line 2268: [J

line 2269: " Function: s:HasLeadingTabs(...) {{{2[J

line 2270: " Returns 1 if any of the given strings have leading tabs[J

line 2271: function s:HasLeadingTabs(...)[J

line 2279: " Function: s:HasCStyleComments() {{{2[J

line 2280: " Returns 1 if the current filetype has c style comment delimiters[J

line 2281: function s:HasCStyleComments()[J

line 2284: [J

line 2285: " Function: s:IsCommentedNormOrSexy(lineNum) {{{2[J

line 2286: "This function is used to determine whether the given line is commented with[J

line 2287: "either set of delimiters or if it is part of a sexy comment[J

line 2288: "[J

line 2289: " Args:[J

line 2290: "   -lineNum: the line number of the line to check[J

line 2291: function s:IsCommentedNormOrSexy(lineNum)[J

line 2305: [J

line 2306: " Function: s:IsCommented(left, right, line) {{{2[J

line 2307: "This function is used to determine whether the given line is commented with[J

line 2308: "the given delimiters[J

line 2309: "[J

line 2310: " Args:[J

line 2311: "   -line: the line that to check if commented[J

line 2312: "   -left/right: the left and right delimiters to check for[J

line 2313: function s:IsCommented(left, right, line)[J

line 2320: [J

line 2321: " Function: s:IsCommentedFromStartOfLine(left, line) {{{2[J

line 2322: "This function is used to determine whether the given line is commented with[J

line 2323: "the given delimiters at the start of the line i.e the left delimiter is the[J

line 2324: "first thing on the line (apart from spaces\tabs)[J

line 2325: "[J

line 2326: " Args:[J

line 2327: "   -line: the line that to check if commented[J

line 2328: "   -left: the left delimiter to check for[J

line 2329: function s:IsCommentedFromStartOfLine(left, line)[J

line 2335: [J

line 2336: " Function: s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line) {{{2[J

line 2337: " Finds the type of the outermost delimiters on the line[J

line 2338: "[J

line 2339: " Args:[J

line 2340: "   -line: the line that to check if the outermost comments on it are[J

line 2341: "    left/right[J

line 2342: "   -left/right: the left and right delimiters to check for[J

line 2343: "   -leftAlt/rightAlt: the left and right alternative delimiters to check for[J

line 2344: "[J

line 2345: " Returns:[J

line 2346: "   0 if the line is not commented with either set of delimiters[J

line 2347: "   1 if the line is commented with the left/right delimiter set[J

line 2348: "   2 if the line is commented with the leftAlt/rightAlt delim set[J

line 2349: function s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line)[J

line 2377: [J

line 2378: [J

line 2379: " Function: s:IsDelimValid(delimiter, delIndx, line) {{{2[J

line 2380: " This function is responsible for determining whether a given instance of a[J

line 2381: " comment delimiter is a real delimiter or not. For example, in java the[J

line 2382: " // string is a comment delimiter but in the line:[J

line 2383: "               System.out.println("//");[J

line 2384: " it does not count as a comment delimiter. This function is responsible for[J

line 2385: " distinguishing between such cases. It does so by applying a set of[J

line 2386: " heuristics that are not fool proof but should work most of the time.[J

line 2387: "[J

line 2388: " Args:[J

line 2389: "   -delimiter: the delimiter we are validating[J

line 2390: "   -delIndx: the position of delimiter in line[J

line 2391: "   -line: the line that delimiter occurs in[J

line 2392: "[J

line 2393: " Returns:[J

line 2394: " 0 if the given delimiter is not a real delimiter (as far as we can tell) ,[J

line 2395: " 1 otherwise[J

line 2396: function s:IsDelimValid(delimiter, delIndx, line)[J

line 2455: [J

line 2456: " Function: s:IsNumEven(num) {{{2[J

line 2457: " A small function the returns 1 if the input number is even and 0 otherwise[J

line 2458: " Args:[J

line 2459: "   -num: the number to check[J

line 2460: function s:IsNumEven(num)[J

line 2463: [J

line 2464: " Function: s:IsEscaped(str, indx, escChar) {{{2[J

line 2465: " This function takes a string, an index into that string and an esc char and[J

line 2466: " returns 1 if the char at the index is escaped (i.e if it is preceded by an[J

line 2467: " odd number of esc chars)[J

line 2468: " Args:[J

line 2469: "   -str: the string to check[J

line 2470: "   -indx: the index into str that we want to check[J

line 2471: "   -escChar: the escape char the char at indx may be ESCed with[J

line 2472: function s:IsEscaped(str, indx, escChar)[J

line 2492: [J

line 2493: " Function: s:IsInSexyComment(line) {{{2[J

line 2494: " returns 1 if the given line number is part of a sexy comment[J

line 2495: function s:IsInSexyComment(line)[J

line 2498: [J

line 2499: " Function: s:IsSexyComment(topline, bottomline) {{{2[J

line 2500: " This function takes in 2 line numbers and returns 1 if the lines between and[J

line 2501: " including the given line numbers are a sexy comment. It returns 0 otherwise.[J

line 2502: " Args:[J

line 2503: "   -topline: the line that the possible sexy comment starts on[J

line 2504: "   -bottomline: the line that the possible sexy comment stops on[J

line 2505: function s:IsSexyComment(topline, bottomline)[J

line 2579: [J

line 2580: " Function: s:LastIndexOfDelim(delim, str) {{{2[J

line 2581: " This function takes a string and a delimiter and returns the last index of[J

line 2582: " that delimiter in string[J

line 2583: " Args:[J

line 2584: "   -delim: the delimiter to look for[J

line 2585: "   -str: the string to look for delimiter in[J

line 2586: function s:LastIndexOfDelim(delim, str)[J

line 2617: [J

line 2618: " Function: s:Left(...) {{{2[J

line 2619: " returns left delimiter data[J

line 2620: function s:Left(...)[J

line 2639: [J

line 2640: " Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2641: " This function takes in 2 line numbers and returns the index of the left most[J

line 2642: " char (that is not a space or a tab) on all of these lines.[J

line 2643: " Args:[J

line 2644: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2645: "    well. 0 otherwise[J

line 2646: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2647: "   -topline: the top line to be checked[J

line 2648: "   -bottomline: the bottom line to be checked[J

line 2649: function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2683: [J

line 2684: " Function: s:Multipart() {{{2[J

line 2685: " returns 1 if the current delimiters are multipart[J

line 2686: function s:Multipart()[J

line 2689: [J

line 2690: " Function: s:NerdEcho(msg, typeOfMsg) {{{2[J

line 2691: " Args:[J

line 2692: "   -msg: the message to echo[J

line 2693: "   -typeOfMsg: 0 = warning message[J

line 2694: "               1 = normal message[J

line 2695: function s:NerdEcho(msg, typeOfMsg)[J

line 2704: [J

line 2705: " Function: s:Nested() {{{2[J

line 2706: " returns 1 if the current multipart (if any) delimiters allow nesting[J

line 2707: function s:Nested()[J

line 2710: [J

line 2711: " Function: s:NumberOfLeadingTabs(s) {{{2[J

line 2712: " returns the number of leading tabs in the given string[J

line 2713: function s:NumberOfLeadingTabs(s)[J

line 2716: [J

line 2717: " Function: s:NumLinesInBuf() {{{2[J

line 2718: " Returns the number of lines in the current buffer[J

line 2719: function s:NumLinesInBuf()[J

line 2722: [J

line 2723: " Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2[J

line 2724: " This function takes in a string, 2 delimiters in that string and 2 strings[J

line 2725: " to replace these delimiters with.[J

line 2726: "[J

line 2727: " Args:[J

line 2728: "   -toReplace1: the first delimiter to replace[J

line 2729: "   -toReplace2: the second delimiter to replace[J

line 2730: "   -replacor1: the string to replace toReplace1 with[J

line 2731: "   -replacor2: the string to replace toReplace2 with[J

line 2732: "   -str: the string that the delimiters to be replaced are in[J

line 2733: function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)[J

line 2738: [J

line 2739: " Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2[J

line 2740: " This function takes a string and a delimiter and replaces the left most[J

line 2741: " occurrence of this delimiter in the string with a given string[J

line 2742: "[J

line 2743: " Args:[J

line 2744: "   -toReplace: the delimiter in str that is to be replaced[J

line 2745: "   -replacor: the string to replace toReplace with[J

line 2746: "   -str: the string that contains toReplace[J

line 2747: function s:ReplaceLeftMostDelim(toReplace, replacor, str)[J

line 2762: [J

line 2763: " Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2[J

line 2764: " This function takes a string and a delimiter and replaces the right most[J

line 2765: " occurrence of this delimiter in the string with a given string[J

line 2766: "[J

line 2767: " Args:[J

line 2768: "   -toReplace: the delimiter in str that is to be replaced[J

line 2769: "   -replacor: the string to replace toReplace with[J

line 2770: "   -str: the string that contains toReplace[J

line 2771: "[J

line 2772: function s:ReplaceRightMostDelim(toReplace, replacor, str)[J

line 2787: [J

line 2788: "FUNCTION: s:RestoreScreenState() {{{2[J

line 2789: "[J

line 2790: "Sets the screen state back to what it was when s:SaveScreenState was last[J

line 2791: "called.[J

line 2792: "[J

line 2793: function s:RestoreScreenState()[J

line 2802: [J

line 2803: " Function: s:Right(...) {{{2[J

line 2804: " returns right delimiter data[J

line 2805: function s:Right(...)[J

line 2824: [J

line 2825: " Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2[J

line 2826: " This function takes in 2 line numbers and returns the index of the right most[J

line 2827: " char on all of these lines.[J

line 2828: " Args:[J

line 2829: "   -countCommentedLines: 1 if lines that are commented are to be checked as[J

line 2830: "    well. 0 otherwise[J

line 2831: "   -countEmptyLines: 1 if empty lines are to be counted in the search[J

line 2832: "   -topline: the top line to be checked[J

line 2833: "   -bottomline: the bottom line to be checked[J

line 2834: function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)[J

line 2863: [J

line 2864: "FUNCTION: s:SaveScreenState() {{{2[J

line 2865: "Saves the current cursor position in the current buffer and the window[J

line 2866: "scroll position[J

line 2867: function s:SaveScreenState()[J

line 2871: [J

line 2872: " Function: s:SwapOuterMultiPartDelimsForPlaceHolders(line) {{{2[J

line 2873: " This function takes a line and swaps the outer most multi-part delimiters for[J

line 2874: " place holders[J

line 2875: " Args:[J

line 2876: "   -line: the line to swap the delimiters in[J

line 2877: "[J

line 2878: function s:SwapOuterMultiPartDelimsForPlaceHolders(line)[J

line 2899: [J

line 2900: " Function: s:SwapOuterPlaceHoldersForMultiPartDelims(line) {{{2[J

line 2901: " This function takes a line and swaps the outermost place holders for[J

line 2902: " multi-part delimiters[J

line 2903: " Args:[J

line 2904: "   -line: the line to swap the delimiters in[J

line 2905: "[J

line 2906: function s:SwapOuterPlaceHoldersForMultiPartDelims(line)[J

line 2920: " Function: s:TabbedCol(line, col) {{{2[J

line 2921: " Gets the col number for given line and existing col number. The new col[J

line 2922: " number is the col number when all leading spaces are converted to tabs[J

line 2923: " Args:[J

line 2924: "   -line:the line to get the rel col for[J

line 2925: "   -col: the abs col[J

line 2926: function s:TabbedCol(line, col)[J

line 2931: "FUNCTION: s:TabSpace() {{{2[J

line 2932: "returns a string of spaces equal in length to &tabstop[J

line 2933: function s:TabSpace()[J

line 2942: [J

line 2943: " Function: s:UnEsc(str, escChar) {{{2[J

line 2944: " This function removes all the escape chars from a string[J

line 2945: " Args:[J

line 2946: "   -str: the string to remove esc chars from[J

line 2947: "   -escChar: the escape char to be removed[J

line 2948: function s:UnEsc(str, escChar)[J

line 2951: [J

line 2952: " Function: s:UntabbedCol(line, col) {{{2[J

line 2953: " Takes a line and a col and returns the absolute column of col taking into[J

line 2954: " account that a tab is worth 3 or 4 (or whatever) spaces.[J

line 2955: " Args:[J

line 2956: "   -line:the line to get the abs col for[J

line 2957: "   -col: the col that doesn't take into account tabs[J

line 2958: function s:UntabbedCol(line, col)[J

line 2963: " Section: Comment mapping and menu item setup {{{1[J

line 2964: " ===========================================================================[J

line 2965: [J

line 2966: " Create menu items for the specified modes.  If a:combo is not empty, then[J

line 2967: " also define mappings and show a:combo in the menu items.[J

line 2968: function! s:CreateMaps(modes, target, desc, combo)[J

line 2998: call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')[J

calling function <SNR>14_CreateMaps[J('nx', 'Comment', 'Comment', 'cc')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cc <plug>NERDCommenterComment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Comment<Tab>,cc <plug>NERDCommenterComment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterComment :call NERDComment("x", "Comment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cc <plug>NERDCommenterComment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Comment<Tab>,cc <plug>NERDCommenterComment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 2999: call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')[J

calling function <SNR>14_CreateMaps[J('nx', 'Toggle', 'Toggle', 'c<space>')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("n", "Toggle")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>c<space> <plug>NERDCommenterToggle[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Toggle<Tab>,c<space> <plug>NERDCommenterToggle[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("x", "Toggle")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>c<space> <plug>NERDCommenterToggle[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Toggle<Tab>,c<space> <plug>NERDCommenterToggle[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3000: call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')[J

calling function <SNR>14_CreateMaps[J('nx', 'Minimal', 'Minimal', 'cm')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("n", "Minimal")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cm <plug>NERDCommenterMinimal[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Minimal<Tab>,cm <plug>NERDCommenterMinimal[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("x", "Minimal")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cm <plug>NERDCommenterMinimal[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Minimal<Tab>,cm <plug>NERDCommenterMinimal[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3001: call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')[J

calling function <SNR>14_CreateMaps[J('nx', 'Nested', 'Nested', 'cn')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterNested :call NERDComment("n", "Nested")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cn <plug>NERDCommenterNested[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Nested<Tab>,cn <plug>NERDCommenterNested[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterNested :call NERDComment("x", "Nested")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cn <plug>NERDCommenterNested[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Nested<Tab>,cn <plug>NERDCommenterNested[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3002: call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')[J

calling function <SNR>14_CreateMaps[J('n', 'ToEOL', 'To EOL', 'c$')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterToEOL :call NERDComment("n", "ToEOL")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>c$ <plug>NERDCommenterToEOL[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.To\ EOL<Tab>,c$ <plug>NERDCommenterToEOL[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3003: call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')[J

calling function <SNR>14_CreateMaps[J('nx', 'Invert', 'Invert', 'ci')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("n", "Invert")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>ci <plug>NERDCommenterInvert[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Invert<Tab>,ci <plug>NERDCommenterInvert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("x", "Invert")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>ci <plug>NERDCommenterInvert[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Invert<Tab>,ci <plug>NERDCommenterInvert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3004: call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')[J

calling function <SNR>14_CreateMaps[J('nx', 'Sexy', 'Sexy', 'cs')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("n", "Sexy")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cs <plug>NERDCommenterSexy[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Sexy<Tab>,cs <plug>NERDCommenterSexy[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("x", "Sexy")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cs <plug>NERDCommenterSexy[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Sexy<Tab>,cs <plug>NERDCommenterSexy[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3005: call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')[J

calling function <SNR>14_CreateMaps[J('nx', 'Yank', 'Yank then comment', 'cy')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterYank :call NERDComment("n", "Yank")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cy <plug>NERDCommenterYank[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>,cy <plug>NERDCommenterYank[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterYank :call NERDComment("x", "Yank")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cy <plug>NERDCommenterYank[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>,cy <plug>NERDCommenterYank[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3006: call s:CreateMaps('n',  'Append',     'Append', 'cA')[J

calling function <SNR>14_CreateMaps[J('n', 'Append', 'Append', 'cA')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAppend :call NERDComment("n", "Append")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cA <plug>NERDCommenterAppend[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Append<Tab>,cA <plug>NERDCommenterAppend[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3007: call s:CreateMaps('',   ':',          '-Sep-', '')[J

calling function <SNR>14_CreateMaps[J('', ':', '-Sep-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3008: call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')[J

calling function <SNR>14_CreateMaps[J('nx', 'AlignLeft', 'Left aligned', 'cl')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("n", "AlignLeft")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Left\ aligned<Tab>,cl <plug>NERDCommenterAlignLeft[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("x", "AlignLeft")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cl <plug>NERDCommenterAlignLeft[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Left\ aligned<Tab>,cl <plug>NERDCommenterAlignLeft[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3009: call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')[J

calling function <SNR>14_CreateMaps[J('nx', 'AlignBoth', 'Left and right aligned', 'cb')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("n", "AlignBoth")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>,cb <plug>NERDCommenterAlignBoth[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("x", "AlignBoth")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cb <plug>NERDCommenterAlignBoth[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>,cb <plug>NERDCommenterAlignBoth[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3010: call s:CreateMaps('',   ':',          '-Sep2-', '')[J

calling function <SNR>14_CreateMaps[J('', ':', '-Sep2-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep2- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3011: call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')[J

calling function <SNR>14_CreateMaps[J('nx', 'Uncomment', 'Uncomment', 'cu')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("n", "Uncomment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>cu <plug>NERDCommenterUncomment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Uncomment<Tab>,cu <plug>NERDCommenterUncomment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: xnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("x", "Uncomment")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: xmap <leader>cu <plug>NERDCommenterUncomment[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: xmenu <silent> &Plugin.&comment.Uncomment<Tab>,cu <plug>NERDCommenterUncomment[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3012: call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')[J

calling function <SNR>14_CreateMaps[J('n', 'AltDelims', 'Switch Delimiters', 'ca')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 19: nnoremap <silent> <plug>NERDCommenterAltDelims :call NERDComment("n", "AltDelims")<cr>[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 21: nmap <leader>ca <plug>NERDCommenterAltDelims[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: nmenu <silent> &Plugin.&comment.Switch\ Delimiters<Tab>,ca <plug>NERDCommenterAltDelims[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3013: call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')[J

calling function <SNR>14_CreateMaps[J('i', 'Insert', 'Insert Comment Here', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: imenu <silent> &Plugin.&comment.Insert\ Comment\ Here Insert[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3014: call s:CreateMaps('',   ':',          '-Sep3-', '')[J

calling function <SNR>14_CreateMaps[J('', ':', '-Sep3-', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.-Sep3- :[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3015: call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')[J

calling function <SNR>14_CreateMaps[J('', ':help NERDCommenterContents<CR>', 'Help', '')

line 1:     " Build up a map command like[J

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'[J

line 3:     let plug = '<plug>NERDCommenter' . a:target[J

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'[J

line 5:     let plug_end = '", "' . a:target . '")<cr>'[J

line 6:     " Build up a menu command like[J

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'[J

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')[J

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')[J

line 11:     if strlen(a:combo)[J

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'[J

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo[J

line 14:     endif[J

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)[J

line 16:     " Execute the commands built above for each requested mode.[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 26: menu <silent> &Plugin.&comment.Help :help NERDCommenterContents<CR>[J

line 27:         endif[J

line 28:     endfor[J

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')[J

line 18:         if strlen(a:combo)[J

line 19:             execute mode . plug_start . mode . plug_end[J

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)[J

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug[J

line 22:             endif[J

line 23:         endif[J

line 24:         " Check if the user wants the menu to be displayed.[J

line 25:         if g:NERDMenuMode != 0[J

line 26:             execute mode . menu_command[J

line 27:         endif[J

line 28:     endfor[J

function <SNR>14_CreateMaps returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3016: [J

line 3017: inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>[J

line 3018: [J

line 3019: " switch to/from alternative delimiters (does not use wrapper function)[J

line 3020: nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>[J

line 3021: [J

line 3022: " This is a workaround to enable lazy-loading from supported plugin managers:[J

line 3023: " See https://github.com/scrooloose/nerdcommenter/issues/176[J

line 3024: call s:SetUpForNewFiletype(&filetype, 1)[J

calling function <SNR>14_SetUpForNewFiletype[J('', 1)

line 1:     let ft = a:filetype[J

line 2: [J

line 3:     "for compound filetypes, if we don't know how to handle the full filetype[J

line 4:     "then break it down and use the first part that we know how to handle[J

line 5:     if ft =~ '\.' && !has_key(s:delimiterMap, ft)[J

line 6:         let filetypes = split(a:filetype, '\.')[J

line 7:         for i in filetypes[J

line 8:             if has_key(s:delimiterMap, i)[J

line 9:                 let ft = i[J

line 10:                 break[J

line 11:             endif[J

line 12:         endfor[J

line 13:     endif[J

line 14: [J

line 15:     let b:NERDSexyComMarker = ''[J

line 16: [J

line 17:     if has_key(s:delimiterMap, ft)[J

line 18:         let b:NERDCommenterDelims = s:delimiterMap[ft][J

line 19:         for i in ['left', 'leftAlt', 'right', 'rightAlt'][J

line 20:             if !has_key(b:NERDCommenterDelims, i)[J

line 21:                 let b:NERDCommenterDelims[i] = ''[J

line 22:             endif[J

line 23:         endfor[J

line 24:         for i in ['nested', 'nestedAlt'][J

line 25:             if !has_key(b:NERDCommenterDelims, i)[J

line 26:                 let b:NERDCommenterDelims[i] = 0[J

line 27:             endif[J

line 28:         endfor[J

line 29:         " if g:NERD_<filetype>_alt_style is defined, use the alternate style[J

line 30:         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")[J

line 31:         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit[J

line 32:             call s:SwitchToAlternativeDelimiters(0)[J

line 33:             let b:NERDCommenterFirstInit = 1[J

line 34:         endif[J

line 35:     else[J

line 36:         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()[J

calling function <SNR>14_SetUpForNewFiletype[36]..<SNR>14_CreateDelimMapFromCms[J()

line 1:     if &ft == '' && exists('g:NERDDefaultDelims')[J

line 2:         let delims = g:NERDDefaultDelims[J

line 3:         for i in ['left', 'leftAlt', 'right', 'rightAlt'][J

line 4:             if !has_key(delims, i)[J

line 5:                 let delims[i] = ''[J

line 6:             endif[J

line 7:         endfor[J

line 8:         return delims[J

line 9:     endif[J

line 10:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}[J

function <SNR>14_SetUpForNewFiletype[36]..<SNR>14_CreateDelimMapFromCms returning {'nestedAlt': 0, 'right': '*/', 'neste...Alt': '', 'left': '/*', 'rightAlt': ''}[J

continuing in function <SNR>14_SetUpForNewFiletype[J

line 37:     endif[J

line 38: [J

function <SNR>14_SetUpForNewFiletype returning #0[J

continuing in /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J

line 3025: [J

line 3026: " vim: set foldmethod=marker :[J

finished sourcing /home/connor/.vim/bundle/nerdcommenter/plugin/NERD_commenter.vim[J
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/share/vim/vim81/plugin/**/*.vim"[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell[J

line 4: "  Date:^INov 29, 2013[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if exists("g:loaded_getscriptPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: if &cp[J

line 20:  if &verbose[J

line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 22:  endif[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_getscriptPlugin = "v36"[J

line 26: let s:keepcpo                = &cpo[J

line 27: set cpo&vim[J

line 28: [J

line 29: " ---------------------------------------------------------------------[J

line 30: "  Public Interface: {{{1[J

line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 34: [J

line 35: " ---------------------------------------------------------------------[J

line 36: " Restore Options: {{{1[J

line 37: let &cpo= s:keepcpo[J

line 38: unlet s:keepcpo[J

line 39: [J

line 40: " ---------------------------------------------------------------------[J

line 41: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/share/vim/vim81/plugin/getscriptPlugin.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2016 Oct 30[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")[J

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")[J

line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")[J

line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")[J

line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")[J

line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")[J

line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")[J

line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")[J

line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")[J

line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")[J

line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")[J

line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")[J

line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")[J

line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")[J

line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")[J

line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")[J

line 52: augroup END[J

finished sourcing /usr/share/vim/vim81/plugin/gzip.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/logiPat.vim"[J
line 1: " LogiPat: Boolean logical pattern matcher[J

line 2: "   Author:  Charles E. Campbell[J

line 3: "   Date:    Apr 04, 2016[J

line 4: "   Version: 4[J

line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching[J

line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like most anything else that's free,[J

line 10: "               LogiPat.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: "   Usage: {{{1[J

line 17: "       :LogiPat ...[J

line 18: "[J

line 19: "         Boolean logic supported:[J

line 20: "            () grouping operators[J

line 21: "            !  not the following pattern[J

line 22: "            |  logical or[J

line 23: "            &  logical and[J

line 24: "            "..pattern.."[J

line 25: "^IExample: {{{1[J

line 26: "^I^I:LogiPat !("january"|"february")[J

line 27: "^I^I  would match all strings not containing the strings january[J

line 28: "^I^I  or february[J

line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim[J

line 30: "[J

line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1[J

line 32: "  and will call his name Jesus. He will be great, and will be[J

line 33: "  called the Son of the Most High. The Lord God will give him the[J

line 34: "  throne of his father, David, and he will reign over the house of[J

line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " Load Once: {{{1[J

line 39: if &cp || exists("loaded_logiPat")[J

line 40:  finish[J

line 41: endif[J

line 42: let g:loaded_logiPat = "v4"[J

line 43: let s:keepcpo        = &cpo[J

line 44: set cpo&vim[J

line 45: "DechoRemOn[J

line 46: [J

line 47: " ---------------------------------------------------------------------[J

line 48: " Public Interface: {{{1[J

line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)[J

line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)[J

line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")[J

line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)[J

line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"[J

line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"[J

line 55: [J

line 56: " =====================================================================[J

line 57: " Functions: {{{1[J

line 58: [J

line 59: " ---------------------------------------------------------------------[J

line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2[J

line 61: fun! LogiPat(pat,...)[J

line 146: [J

line 147: " ---------------------------------------------------------------------[J

line 148: " s:String: Vim6.4 doesn't have string() {{{2[J

line 149: func! s:String(str)[J

line 152: [J

line 153: " ---------------------------------------------------------------------[J

line 154: " LP_PatPush: {{{2[J

line 155: fun! s:LP_PatPush(pat)[J

line 162: [J

line 163: " ---------------------------------------------------------------------[J

line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2[J

line 165: fun! s:LP_PatPop(lookup)[J

line 178: [J

line 179: " ---------------------------------------------------------------------[J

line 180: " LP_OpPush: {{{2[J

line 181: fun! s:LP_OpPush(op)[J

line 232: [J

line 233: " ---------------------------------------------------------------------[J

line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2[J

line 235: fun! s:LP_Execute(preclvl)[J

line 265: [J

line 266: " ---------------------------------------------------------------------[J

line 267: " LP_Not: writes a logical-not for a pattern {{{2[J

line 268: fun! s:LP_Not(pat)[J

line 279: [J

line 280: " ---------------------------------------------------------------------[J

line 281: " LP_Or: writes a logical-or branch using two patterns {{{2[J

line 282: fun! s:LP_Or(pat1,pat2)[J

line 288: [J

line 289: " ---------------------------------------------------------------------[J

line 290: " LP_And: writes a logical-and concat using two patterns {{{2[J

line 291: fun! s:LP_And(pat1,pat2)[J

line 297: [J

line 298: " ---------------------------------------------------------------------[J

line 299: " StackLook: {{{2[J

line 300: fun! s:StackLook(description)[J

line 334: [J

line 335: " ---------------------------------------------------------------------[J

line 336: "  Cleanup And Modeline: {{{1[J

line 337: let &cpo= s:keepcpo[J

line 338: unlet s:keepcpo[J

line 339: " vim: ts=4 fdm=marker[J

finished sourcing /usr/share/vim/vim81/plugin/logiPat.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/manpager.vim"[J
line 1: " Vim plugin for using Vim as manpager.[J

line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>[J

line 3: " Last Change: 2018 Feb 04[J

line 4: [J

line 5: command! -nargs=0 MANPAGER call s:ManPager() | delcommand MANPAGER[J

line 6: [J

line 7: function! s:ManPager()[J

finished sourcing /usr/share/vim/vim81/plugin/manpager.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2018 Jul 3[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: " - the "CursorMoved" autocmd event is not available.[J

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_matchparen = 1[J

line 13: [J

line 14: if !exists("g:matchparen_timeout")[J

line 15:   let g:matchparen_timeout = 300[J

line 16: endif[J

line 17: if !exists("g:matchparen_insert_timeout")[J

line 18:   let g:matchparen_insert_timeout = 60[J

line 19: endif[J

line 20: [J

line 21: augroup matchparen[J

line 22:   " Replace all matchparen autocommands[J

line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()[J

line 24:   if exists('##TextChanged')[J

line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()[J

line 26:   endif[J

line 27: augroup END[J

line 28: [J

line 29: " Skip the rest if it was already done.[J

line 30: if exists("*s:Highlight_Matching_Pair")[J

line 31:   finish[J

line 32: endif[J

line 33: [J

line 34: let s:cpo_save = &cpo[J

line 35: set cpo-=C[J

line 36: [J

line 37: " The function that is invoked (very often) to define a ":match" highlighting[J

line 38: " for any matching paren.[J

line 39: function! s:Highlight_Matching_Pair()[J

line 197: [J

line 198: " Define commands that will disable and enable the plugin.[J

line 199: command! DoMatchParen call s:DoMatchParen()[J

line 200: command! NoMatchParen call s:NoMatchParen()[J

line 201: [J

line 202: func! s:NoMatchParen()[J

line 209: [J

line 210: func! s:DoMatchParen()[J

line 216: [J

line 217: let &cpo = s:cpo_save[J

line 218: unlet s:cpo_save[J

finished sourcing /usr/share/vim/vim81/plugin/matchparen.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^IFeb 08, 2016[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_netrwPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_netrwPlugin = "v156"[J

line 24: let s:keepcpo = &cpo[J

line 25: set cpo&vim[J

line 26: "DechoRemOn[J

line 27: [J

line 28: " ---------------------------------------------------------------------[J

line 29: " Public Interface: {{{1[J

line 30: [J

line 31: " Local Browsing Autocmds: {{{2[J

line 32: augroup FileExplorer[J

line 33:  au![J

line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif[J

line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))[J

line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))[J

line 37:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))[J

line 39:  endif[J

line 40: augroup END[J

line 41: [J

line 42: " Network Browsing Reading Writing: {{{2[J

line 43: augroup Network[J

line 44:  au![J

line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))[J

line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 50:  try                                                       [J

line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            [J

line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 54:  endtry[J

line 55: augroup END[J

line 56: [J

line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)[J

line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)[J

line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)[J

line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)[J

line 63: [J

line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2[J

line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)[J

line 73: [J

line 74: " Commands: NetrwSettings {{{2[J

line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)[J

line 77: [J

line 78: " Maps:[J

line 79: if !exists("g:netrw_nogx")[J

line 80:  if maparg('gx','n') == ""[J

line 81:   if !hasmapto('<Plug>NetrwBrowseX')[J

line 82:    nmap <unique> gx <Plug>NetrwBrowseX[J

line 83:   endif[J

line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>[J

line 85:  endif[J

line 86:  if maparg('gx','v') == ""[J

line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')[J

line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis[J

line 89:   endif[J

line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>[J

line 91:  endif[J

line 92: endif[J

line 93: if exists("g:netrw_usetab") && g:netrw_usetab[J

line 94:  if maparg('<c-tab>','n') == ""[J

line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink[J

line 96:  endif[J

line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>[J

line 98: endif[J

line 99: [J

line 100: " ---------------------------------------------------------------------[J

line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2[J

line 102: fun! s:LocalBrowse(dirname)[J

line 148: [J

line 149: " ---------------------------------------------------------------------[J

line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2[J

line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on[J

line 152: "             them, which checks if they're directories and will create a directory[J

line 153: "             listing when appropriate.[J

line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()[J

line 155: "             has already been called.[J

line 156: fun! s:VimEnter(dirname)[J

line 164: [J

line 165: " ---------------------------------------------------------------------[J

line 166: " NetrwStatusLine: {{{1[J

line 167: fun! NetrwStatusLine()[J

line 178: [J

line 179: " ------------------------------------------------------------------------[J

line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 184: fun! NetUserPass(...)[J

line 208: [J

line 209: " ------------------------------------------------------------------------[J

line 210: " Modelines And Restoration: {{{1[J

line 211: let &cpo= s:keepcpo[J

line 212: unlet s:keepcpo[J

line 213: " vim:ts=8 fdm=marker[J

finished sourcing /usr/share/vim/vim81/plugin/netrwPlugin.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper") || !has("clientserver")[J

line 7:   finish[J

finished sourcing /usr/share/vim/vim81/plugin/rrhelper.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/share/vim/vim81/plugin/spellfile.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v29"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))[J

line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))[J

line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 47: augroup END[J

line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)[J

line 49: [J

line 50: " ---------------------------------------------------------------------[J

line 51: " Restoration And Modelines: {{{1[J

line 52: " vim: fdm=marker[J

line 53: let &cpo= s:keepcpo[J

line 54: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim81/plugin/tarPlugin.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>[J

line 3: " Last Change: 2015 Sep 08[J

line 4: "[J

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and[J

line 6: " $VIMRUNTIME/syntax/2html.vim[J

line 7: "[J

line 8: " TODO: {{{[J

line 9: "   * Options for generating the CSS in external style sheets. New :TOcss[J

line 10: "     command to convert the current color scheme into a (mostly) generic CSS[J

line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start[J

line 12: "     by Erik Falor[J

line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).[J

line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,[J

line 15: "     term) to use for the styling. Suggestion by "nacitar".[J

line 16: "   * Add way to override or specify which RGB colors map to the color numbers[J

line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".[J

line 18: "   * Disable filetype detection until after all processing is done.[J

line 19: "   * Add option for not generating the hyperlink on stuff that looks like a[J

line 20: "     URL? Or just color the link to fit with the colorscheme (and only special[J

line 21: "     when hovering)?[J

line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable[J

line 23: "     regions is turned on. Possible solution: Add normal text line numbers with[J

line 24: "     display:none, set to display:inline for print style sheets, and hide[J

line 25: "     <input> elements for print, to allow Opera printing multiple pages (and[J

line 26: "     other uncopyable areas?). May need to make the new text invisible to IE[J

line 27: "     with conditional comments to prevent copying it, IE for some reason likes[J

line 28: "     to copy hidden text. Other browsers too?[J

line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is[J

line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome[J

line 31: "     on Windows). Perhaps it is font related?[J

line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains[J

line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps[J

line 34: "     on diff lines though.[J

line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:[J

line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion[J

line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is[J

line 38: "     accepted to modify it.[J

line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold[J

line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress[J

line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml[J

line 42: "     does not show the whole diff filler as it is supposed to?[J

line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate[J

line 44: "     invalid content. Can/should anything be done about this? Maybe a separate[J

line 45: "     plugin to correct 'isprint' based on encoding?[J

line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without[J

line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.[J

line 48: "   * Font auto-detection similar to[J

line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of[J

line 50: "     platforms.[J

line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.[J

line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :[J

line 53: "^I- listchars support[J

line 54: "^I- full-line background highlight[J

line 55: "^I- other?[J

line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it[J

line 57: "     free with full-line background highlight above).[J

line 58: "   * Restore open/closed folds and cursor position after processing each file[J

line 59: "     with option not to restore for speed increase.[J

line 60: "   * Add extra meta info (generation time, etc.)?[J

line 61: "   * Tidy up so we can use strict doctype in even more situations[J

line 62: "   * Implementation detail: add threshold for writing the lines to the html[J

line 63: "     buffer before we're done (5000 or so lines should do it)[J

line 64: "   * TODO comments for code cleanup scattered throughout[J

line 65: "}}}[J

line 66: [J

line 67: if exists('g:loaded_2html_plugin')[J

line 68:   finish[J

line 69: endif[J

line 70: let g:loaded_2html_plugin = 'vim7.4_v2'[J

line 71: [J

line 72: "[J

line 73: " Changelog: {{{[J

line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing[J

line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to[J

line 76: "                           take a list so it is easier to specfiy fallback[J

line 77: "                           fonts in the generated CSS.[J

line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and[J

line 79: "^I^I^I    also for version-specific modelines like "vim>703:".[J

line 80: "[J

line 81: "   7.3 updates: {{{[J

line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using[J

line 83: "^I^I^I    g:html_line_ids=0. Allow customizing[J

line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using[J

line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion[J

line 86: "^I^I^I    is started.[J

line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and[J

line 88: "^I^I^I    insert modeline to set it to manual.[J

line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a[J

line 90: "^I^I^I    duplicate of one buffer instead of including both.[J

line 91: "^I^I^I    Add anchors to each line so you can put '#L123'[J

line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123[J

line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds[J

line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.[J

line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.[J

line 96: "^I^I^I    Allow TOhtml to chain together with other commands[J

line 97: "^I^I^I    using |.[J

line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple[J

line 99: "^I^I^I    highlight groups make up the start-of-modeline text.[J

line 100: "^I^I^I    Improve render time of page with uncopyable regions[J

line 101: "^I^I^I    by not using one-input-per-char. Change name of[J

line 102: "^I^I^I    uncopyable option from html_unselectable to[J

line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and[J

line 104: "^I^I^I    default to inserting invalid markup for uncopyable[J

line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable[J

line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).[J

line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to[J

line 108: "^I^I^I    eliminate post-processing substitute commands in[J

line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary[J

line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor[J

line 111: "^I^I^I    speed improvements. Fix modeline mangling in[J

line 112: "^I^I^I    generated output so it works for text in the first[J

line 113: "^I^I^I    column. Fix missing line number and fold column in[J

line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px[J

line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add[J

line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for[J

line 117: "^I^I^I    the new default foldtext added in v11, as the patch[J

line 118: "^I^I^I    adding it has not yet been included in Vim.[J

line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian[J

line 120: "^I^I^I    Brabandt in[J

line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.[J

line 122: "^I^I^I    This patch has not yet been included in Vim, thus[J

line 123: "^I^I^I    these changes are removed in the next version.[J

line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside[J

line 125: "^I^I^I    multiple nested folds with dynamic folding on.[J

line 126: "^I^I^I    Also fix problem with foldtext in this situation.[J

line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css[J

line 128: "^I^I^I    and without html_no_pre, default value same as[J

line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use[J

line 130: "^I^I^I    'fileencoding' for converted document encoding if[J

line 131: "^I^I^I    'buftype' indicates a special buffer which isn't[J

line 132: "^I^I^I    written.[J

line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab[J

line 134: "^I^I^I    characters in generated output (Andy Spencer).[J

line 135: "^I^I^I    Escape text that looks like a modeline so Vim[J

line 136: "^I^I^I    doesn't use anything in the converted HTML as a[J

line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts[J

line 138: "^I^I^I    before the conversion range. Remove fold column when[J

line 139: "^I^I^I    there are no folds.[J

line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:[J

line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.[J

line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not[J

line 143: "^I^I^I    supported by all major browsers according to[J

line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and[J

line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make[J

line 146: "^I^I^I    HTML encoding to Vim encoding detection be[J

line 147: "^I^I^I    case-insensitive for built-in pairs.[J

line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be[J

line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use[J

line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by[J

line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated[J

line 152: "^I^I^I    file matches its indicated charset. Add charsets for[J

line 153: "^I^I^I    all of Vim's natively supported encodings.[J

line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other[J

line 155: "^I^I^I    user settings interfering with diff mode generation,[J

line 156: "^I^I^I    trailing whitespace (e.g. line number column) when[J

line 157: "^I^I^I    using html_no_pre, and bugs when using[J

line 158: "^I^I^I    html_hover_unfold.[J

line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync[J

line 160: "^I^I^I    folds in diff mode when first line was folded.[J

line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode[J

line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css[J

line 163: "^I^I^I    default to true when not set to anything. Use strict[J

line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to[J

line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension[J

line 166: "^I^I^I    when using this option. Add meta tag for settings.[J

line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the[J

line 168: "^I^I^I    diff colors and the normal syntax colors[J

line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output[J

line 170: "}}}[J

line 171: "}}}[J

line 172: [J

line 173: " Define the :TOhtml command when:[J

line 174: " - 'compatible' is not set[J

line 175: " - this plugin was not already loaded[J

line 176: " - user commands are available. {{{[J

line 177: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)[J

line 179: endif "}}}[J

line 180: [J

line 181: " Make sure any patches will probably use consistent indent[J

line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker[J

finished sourcing /usr/share/vim/vim81/plugin/tohtml.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell[J

line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v37"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)[J

line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)[J

line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: augroup Vimball[J

line 30:  au![J

line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 37: augroup END[J

line 38: [J

line 39: " =====================================================================[J

line 40: " Restoration And Modelines: {{{1[J

line 41: " vim: fdm=marker[J

line 42: let &cpo= s:keepcpo[J

line 43: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim81/plugin/vimballPlugin.vim[J
chdir(/usr/share/vim/vim81/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/share/vim/vim81/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^ISep 13, 2016[J

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v28"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Options: {{{1[J

line 29: if !exists("g:zipPlugin_ext")[J

line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'[J

line 31: endif[J

line 32: [J

line 33: " ---------------------------------------------------------------------[J

line 34: " Public Interface: {{{1[J

line 35: augroup zip[J

line 36:  au![J

line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 41: [J

line 42:  if has("unix")[J

line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 47:  endif[J

line 48: [J

line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'[J

line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))[J

line 50: augroup END[J

line 51: [J

line 52: " ---------------------------------------------------------------------[J

line 53: "  Restoration And Modelines: {{{1[J

line 54: "  vim: fdm=marker[J

line 55: let &cpo= s:keepcpo[J

line 56: unlet s:keepcpo[J

finished sourcing /usr/share/vim/vim81/plugin/zipPlugin.vim[J
Searching for "pack/*/start/*" in "/home/connor/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/home/connor/.vim/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/share/vim/vim81/pack/*/start/*"[J
Searching for "/usr/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/home/connor/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "plugin/**/*.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/home/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/share/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"[J
Searching for "/usr/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/home/connor/.vim/after/plugin/**/*.vim"[J
not found in 'runtimepath': "plugin/**/*.vim"[J
Reading viminfo file "/home/connor/.viminfo" info oldfiles[J[?2004h
Press ENTER or type command to continue[?25h[?1049h[22;0;0t[?1h=[?2004h[1;56r[?12h[?12l[27m[23m[29m[m[H[2J[?25l[56;1HExecuting BufEnter Autocommands for "*"
autocommand :call s:SetUpForNewFiletype(&filetype, 0)
line 0: :call s:SetUpForNewFiletype(&filetype, 0)
calling function <SNR>14_SetUpForNewFiletype('', 0)
line 1:     let ft = a:filetype
line 2:
line 3:     "for compound filetypes, if we don't know how to handle the full filetype
line 4:     "then break it down and use the first part that we know how to handle
line 5:     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
line 6:[9Clet filetypes = split(a:filetype, '\.')
line 7:[9Cfor i in filetypes
line 8:[13Cif has_key(s:delimiterMap, i)
line 9:[17Clet ft = i
line 10:[17Cbreak
line 11:[13Cendif
line 12:[9Cendfor
line 13:     endif
line 14:
line 15:     let b:NERDSexyComMarker = ''
line 16:
line 17:     if has_key(s:delimiterMap, ft)
line 18:[9Clet b:NERDCommenterDelims = s:delimiterMap[ft]
line 19:[9Cfor i in ['left', 'leftAlt', 'right', 'rightAlt']
line 20:[13Cif !has_key(b:NERDCommenterDelims, i)
line 21:[17Clet b:NERDCommenterDelims[i] = ''
line 22:[13Cendif
line 23:[9Cendfor
line 24:[9Cfor i in ['nested', 'nestedAlt']
line 25:[13Cif !has_key(b:NERDCommenterDelims, i)
line 26:[17Clet b:NERDCommenterDelims[i] = 0
line 27:[13Cendif
line 28:[9Cendfor
line 29:[9C" if g:NERD_<filetype>_alt_style is defined, use the alternate style
line 30:[9Clet b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
line 31:[9Cif exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirs
[55;105Ht[56;1HInit
line 32:[13Ccall s:SwitchToAlternativeDelimiters(0)
line 33:[13Clet b:NERDCommenterFirstInit = 1
line 34:[9Cendif
line 35:     else
line 36:[9Clet b:NERDCommenterDelims = s:CreateDelimMapFromCms()
calling function <SNR>14_SetUpForNewFiletype[36]..<SNR>14_CreateDelimMapFromCms()
line 1:     if &ft == '' && exists('g:NERDDefaultDelims')
line 2:[9Clet delims = g:NERDDefaultDelims
line 3:[9Cfor i in ['left', 'leftAlt', 'right', 'rightAlt']
line 4:[13Cif !has_key(delims, i)
line 5:[17Clet delims[i] = ''
line 6:[13Cendif
line 7:[9Cendfor
line 8:[9Creturn delims
line 9:     endif
line 10:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': subst
[55;105Hi[56;1Htute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt
[55;105H'[56;1H: 0}
function <SNR>14_SetUpForNewFiletype[36]..<SNR>14_CreateDelimMapFromCms returning {'nestedAlt': 0, 'righ
[55;105Ht[56;1H[38;5;121m-- More --[?25h[m[56;1H[K[56;1H': '*/', 'neste...Alt': '', 'left': '/*', 'rightAlt': ''}
[38;5;121m-- More --[m[56;1H[K[?25l[56;1Hcontinuing in function <SNR>14_SetUpForNewFiletype
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hline 37:     endif
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hline 38:
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hfunction <SNR>14_SetUpForNewFiletype returning #0
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hcontinuing in BufEnter Autocommands for "*"
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1HExecuting BufEnter Autocommands for "*"
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hautocommand sil call s:LocalBrowse(expand("<amatch>"))
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hline 0: sil call s:LocalBrowse(expand("<amatch>"))
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1HExecuting VimEnter Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lautocommand call youcompleteme#Enable()
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lline 0: call youcompleteme#Enable()
Searching for "autoload/youcompleteme.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/ho
[55;105Hm[56;1He/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/s
[55;105Hh[56;1Hare/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lSearching for "/home/connor/.vim/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
Searching for "/home/connor/.vim/bundle/Vundle.vim/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
Searching for "/home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
chdir(/home/connor/.vim/bundle/YouCompleteMe/autoload)
[38;5;121mPress ENTER or type command to continue[m
fchdir() to previous dir
[38;5;121mPress ENTER or type command to continue[m
line 0: sourcing "/home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17:
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21:
line 22: " This needs to be called outside of a function
line 23: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 24: let s:omnifunc_mode = 0
line 25: let s:defer_omnifunc = 1
line 26:
line 27: let s:old_cursor_position = []
line 28: let s:cursor_moved = 0
line 29: let s:moved_vertically_in_insert_mode = 0
line 30: let s:previous_num_chars_on_current_line = strlen( getline('.') )
line 31: let s:previous_allowed_buffer_number = 0
line 32:
line 33:
line 34: function! s:UsingPython2()
line 42:
line 43:
line 44: let s:using_python2 = s:UsingPython2()
calling function <SNR>27_UsingPython2()
line 1:   " I'm willing to bet quite a bit that sooner or later, somebody will ask us to
line 2:   " make it configurable which version of Python we use.
line 3:   if has('python')
line 4:     return 1
function <SNR>27_UsingPython2 returning #1
continuing in /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
line 45: let s:python_until_eof = s:using_python2 ? "python << EOF" : "python3 << EOF"
line 46: let s:python_command = s:using_python2 ? "py " : "py3 "
line 47:
line 48:
line 49: function! s:Pyeval( eval_string )
line 55:
line 56:
line 57: function! youcompleteme#Enable()
line 125:
line 126:
line 127: function! youcompleteme#EnableCursorMovedAutocommands()
[38;5;121m-- More --[?25h SPACE/d/j: screen/page/line down, b/u/k: up, q: quit [m[56;1H[K[56;1H
[?25l[97m[41mError detected while processing /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:[m
[93mline  133:[m
[97m[41mInterrupted[m
finished sourcing /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
[38;5;121mPress ENTER or type command to continue[m
continuing in VimEnter Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[m
calling function youcompleteme#Enable()
line 1:   call s:SetUpBackwardsCompatibility()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline    1:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpBackwardsCompatibility[m
[38;5;121mPress ENTER or type command to continue[m
line 2:
line 3:   " This can be 0 if YCM libs are old or -1 if an exception occured while
line 4:   " executing the function.
line 5:   if s:SetUpPython() != 1
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline    5:[m
[97m[41mE117: Unknown function: s:SetUpPython[m
[38;5;121mPress ENTER or type command to continue[m
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline    5:[m
[97m[41mE15: Invalid expression: s:SetUpPython() != 1[m
[38;5;121mPress ENTER or type command to continue[m
line 6:     return
line 7:   endif
line 8:
line 9:   call s:SetUpCommands()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline    9:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpCommands[m
[38;5;121mPress ENTER or type command to continue[m
line 10:   call s:SetUpCpoptions()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   10:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpCpoptions[m
[38;5;121mPress ENTER or type command to continue[m
line 11:   call s:SetUpCompleteopt()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   11:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpCompleteopt[m
[38;5;121mPress ENTER or type command to continue[m
line 12:   call s:SetUpKeyMappings()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   12:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpKeyMappings[m
[38;5;121mPress ENTER or type command to continue[m
line 13:
line 14:   if g:ycm_show_diagnostics_ui
line 15:     call s:TurnOffSyntasticForCFamily()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   15:[m
[97m[41mE117: Unknown function: <SNR>27_TurnOffSyntasticForCFamily[m
[38;5;121mPress ENTER or type command to continue[m
line 16:   endif
line 17:
line 18:   call s:SetUpSigns()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   18:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpSigns[m
[38;5;121mPress ENTER or type command to continue[m
line 19:   call s:SetUpSyntaxHighlighting()
[97m[41mError detected while processing function youcompleteme#Enable:[m
[93mline   19:[m
[97m[41mE117: Unknown function: <SNR>27_SetUpSyntaxHighlighting[m
[38;5;121mPress ENTER or type command to continue[m
line 20:
line 21:   if g:ycm_allow_changing_updatetime && &updatetime > 2000
line 22:     set ut=2000
line 23:   endif
line 24:
line 25:   call youcompleteme#EnableCursorMovedAutocommands()
Searching for "autoload/youcompleteme.vim" in "/home/connor/.vim,/home/connor/.vim/bundle/Vundle.vim,/ho
[55;105Hm[56;1He/connor/.vim/bundle/YouCompleteMe,/home/connor/.vim/bundle/nerdcommenter,/usr/share/vim/vimfiles,/usr/s
[55;105Hh[56;1Hare/vim/vim81,/usr/share/vim/vimfiles/after,/home/connor/.vim/after"
[38;5;121mPress ENTER or type command to continue[m
Searching for "/home/connor/.vim/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
Searching for "/home/connor/.vim/bundle/Vundle.vim/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
Searching for "/home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
chdir(/home/connor/.vim/bundle/YouCompleteMe/autoload)
[38;5;121mPress ENTER or type command to continue[m
fchdir() to previous dir
[38;5;121mPress ENTER or type command to continue[m
line 25: sourcing "/home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim"
[38;5;121mPress ENTER or type command to continue[m
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17:
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21:
line 22: " This needs to be called outside of a function
line 23: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 24: let s:omnifunc_mode = 0
line 25: let s:defer_omnifunc = 1
line 26:
line 27: let s:old_cursor_position = []
line 28: let s:cursor_moved = 0
line 29: let s:moved_vertically_in_insert_mode = 0
line 30: let s:previous_num_chars_on_current_line = strlen( getline('.') )
line 31: let s:previous_allowed_buffer_number = 0
line 32:
line 33:
line 34: function! s:UsingPython2()
line 42:
line 43:
line 44: let s:using_python2 = s:UsingPython2()
calling function <SNR>27_UsingPython2()
line 1:   " I'm willing to bet quite a bit that sooner or later, somebody will ask us to
line 2:   " make it configurable which version of Python we use.
line 3:   if has('python')
line 4:     return 1
function <SNR>27_UsingPython2 returning #1
continuing in /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
line 45: let s:python_until_eof = s:using_python2 ? "python << EOF" : "python3 << EOF"
line 46: let s:python_command = s:using_python2 ? "py " : "py3 "
line 47:
line 48:
line 49: function! s:Pyeval( eval_string )
line 55:
line 56:
line 57: function! youcompleteme#Enable()
[97m[41mError detected while processing /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:[m
[93mline  124:[m
[97m[41mE127: Cannot redefine function youcompleteme#Enable: It is in use[m
[38;5;121mPress ENTER or type command to continue[m
line 125:
line 126:
line 127: function! youcompleteme#EnableCursorMovedAutocommands()

line 134:
line 135:
line 136: function! youcompleteme#DisableCursorMovedAutocommands()

line 140:
line 141:
line 142: function! youcompleteme#GetErrorCount()

line 145:
line 146:
line 147: function! youcompleteme#GetWarningCount()

line 150:
line 151:
line 152: function! s:SetUpPython() abort

line 193:
line 194:
line 195: function! s:SetUpKeyMappings()

line 245:
line 246:
line 247: function! s:SetUpSigns()

line 280:
line 281:
line 282: function! s:SetUpSyntaxHighlighting()

line 302:
line 303:
line 304: function! s:SetUpBackwardsCompatibility()

line 318:
line 319:
line 320: " Needed so that YCM is used instead of Syntastic
line 321: function! s:TurnOffSyntasticForCFamily()

line 327:
line 328:
line 329: function! s:AllowedToCompleteInCurrentBuffer()

line 346:
line 347:
line 348: function! s:VisitedBufferRequiresReparse()

line 359:
line 360:
line 361: function! s:SetUpCommands()

line 372:
line 373:
line 374: function! s:SetUpCpoptions()

line 385:
line 386:
line 387: function! s:SetUpCompleteopt()

line 409:
line 410:
line 411: " For various functions/use-cases, we want to keep track of whether the buffer
line 412: " has changed since the last time they were invoked. We keep the state of
line 413: " b:changedtick of the last time the specific function was called in
line 414: " b:ycm_changedtick.
line 415: function! s:SetUpYcmChangedTick()

line 421:
line 422:
line 423: function! s:OnVimLeave()

line 426:
line 427:
line 428: function! s:OnCompleteDone()

line 431:
line 432:
line 433: function! s:OnBufferReadPre(filename)

line 444:
line 445: function! s:OnBufferRead()

line 465:
line 466:
line 467: function! s:OnBufferEnter()

line 475:
line 476:
line 477: function! s:OnBufferUnload( deleted_buffer_file )

line 485:
line 486:
line 487: function! s:OnCursorHold()

line 495:
line 496:
line 497: function! s:OnFileReadyToParse()

line 514:
line 515:
line 516: function! s:SetCompleteFunc()

line 520:
line 521:
line 522: function! s:SetOmnicompleteFunc()

line 535:
line 536: function! s:OnCursorMovedInsertMode()

line 571:
line 572:
line 573: function! s:OnCursorMovedNormalMode()

line 581:
line 582:
line 583: function! s:OnInsertLeave()

line 596:
line 597:
line 598: function! s:OnInsertEnter()

line 607:
line 608:
line 609: function! s:UpdateCursorMoved()

line 618:
line 619:
line 620: function! s:BufferTextChangedSinceLastMoveInInsertMode()

line 634:
line 635:
line 636: function! s:ClosePreviewWindowIfNeeded()

line 650:
line 651:
line 652: function! s:IdentifierFinishedOperations()

line 659:
line 660:
line 661: " Returns 1 when inside comment and 2 when inside string
line 662: function! s:InsideCommentOrString()

line 678:
line 679:
line 680: function! s:InsideCommentOrStringAndShouldStop()

line 692:
line 693:
line 694: function! s:OnBlankLine()

line 697:
line 698:
line 699: function! s:InvokeCompletion()

line 729:
line 730:
line 731: function! s:GetCompletions()

line 734:
line 735:
line 736: " This is our main entry point. This is what vim calls to get completions.
line 737: function! youcompleteme#Complete( findstart, base )

line 765:
line 766:
line 767: function! youcompleteme#OmniComplete( findstart, base )

line 780:
line 781:
line 782: function! youcompleteme#ServerPid()

line 785:
line 786:
line 787: function! s:RestartServer()

line 790:
line 791:
line 792: function! s:ShowDetailedDiagnostic()

line 795:
line 796:
line 797: function! s:DebugInfo()

line 804:
line 805:
line 806: function! s:ToggleLogs(...)

line 813:
line 814:
line 815: function! s:CompleterCommand(...)

line 836:
line 837:
line 838: function! youcompleteme#OpenGoToList()

line 844:
line 845:
line 846: function! youcompleteme#LogsComplete( arglead, cmdline, cursorpos )

line 849:
line 850:
line 851: function! youcompleteme#SubCommandsComplete( arglead, cmdline, cursorpos )

line 855:
line 856:
line 857: function! s:ForceCompile()

line 870:
line 871:
line 872: function! s:ForceCompileAndDiagnostics()

line 879:
line 880:
line 881: function! s:ShowDiagnostics()

line 895:
line 896:
line 897: " This is basic vim plugin boilerplate
line 898: let &cpo = s:save_cpo
line 899: unlet s:save_cpo
finished sourcing /home/connor/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim
[38;5;121mPress ENTER or type command to continue[m
continuing in function youcompleteme#Enable
[38;5;121mPress ENTER or type command to continue[m
calling function youcompleteme#Enable[25]..youcompleteme#EnableCursorMovedAutocommands()
line 1:     augroup ycmcompletemecursormove
line 2:[9Cautocmd!
line 3:[9Cautocmd CursorMovedI * call s:OnCursorMovedInsertMode()
line 4:[9Cautocmd CursorMoved * call s:OnCursorMovedNormalMode()
line 5:     augroup END
function youcompleteme#Enable[25]..youcompleteme#EnableCursorMovedAutocommands returning #0
continuing in function youcompleteme#Enable
line 26:   augroup youcompleteme
line 27:     autocmd!
line 28:     " Note that these events will NOT trigger for the file vim is started with;
line 29:     " so if you do "vim foo.cc", these events will not trigger when that buffer
line 30:     " is read. This is because youcompleteme#Enable() is called on VimEnter and
line 31:     " that happens *after" BufRead/BufEnter has already triggered for the
line 32:     " initial file.
line 33:     " We also need to trigger buf init code on the FileType event because when
line 34:     " the user does :enew and then :set ft=something, we need to run buf init
line 35:     " code again.
line 36:     autocmd BufReadPre * call s:OnBufferReadPre( expand( '<afile>:p' ) )
line 37:     autocmd BufRead,FileType * call s:OnBufferRead()
line 38:     autocmd BufEnter * call s:OnBufferEnter()
line 39:     autocmd BufUnload * call s:OnBufferUnload( expand( '<afile>:p' ) )
line 40:     autocmd CursorHold,CursorHoldI * call s:OnCursorHold()
line 41:     autocmd InsertLeave * call s:OnInsertLeave()
line 42:     autocmd InsertEnter * call s:OnInsertEnter()
line 43:     autocmd VimLeave * call s:OnVimLeave()
line 44:     autocmd CompleteDone * call s:OnCompleteDone()
line 45:   augroup END
line 46:
line 47:   " Setting the omnifunc require us to ask the server if it has a Native
line 48:   " Semantic Completer for the current buffer's filetype. When vim first start
line 49:   " this mean that we have to wait for the server to be up and running which
line 50:   " would block vim's GUI. To avoid this we defer setting the omnifunc the
line 51:   " first time to when we enter Insert mode and then update it on every
line 52:   " BufferVisit as normal.
line 53:   if s:defer_omnifunc
line 54:     augroup ycm_defer_omnifunc
line 55:[7Cautocmd!
line 56:[7Cautocmd InsertEnter * call s:SetOmnicompleteFunc() | let s:defer_omnifunc = 0 | autocmd!
[55;105Hy[56;1Hcm_defer_omnifunc
line 59:     augroup END
line 60:   endif
line 61:
line 62:   " Calling these once solves the problem of BufReadPre/BufRead/BufEnter not
line 63:   " triggering for the first loaded file. This should be the last commands
line 64:   " executed in this function!
line 65:   call s:OnBufferReadPre( expand( '<afile>:p' ) )
calling function youcompleteme#Enable[65]..<SNR>27_OnBufferReadPre('')
line 1:   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
line 2:
line 3:   if threshold > 0 && getfsize( a:filename ) > threshold
line 4:     echohl WarningMsg | echomsg "YouCompleteMe is disabled in this buffer; " . "the file exceede
[55;105Hd[56;2Hthe max size (see YCM options)." | echohl None
line 4:  echomsg "YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM
options)." | echohl None
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hline 4:  echohl None
[38;5;121m-- More --[?25h[m[56;1H[K[?25l[56;1Hline 8:     let b:ycm_largefile = 1
[38;5;121m-- More --[?25h[m[56;1H[K[56;1H
[?25lfunction youcompleteme#Enable[65]..<SNR>27_OnBufferReadPre aborted
continuing in function youcompleteme#Enable
function youcompleteme#Enable aborted
continuing in VimEnter Autocommands for "*"
[94C:[1;5H[56;95H[K[56;1H:[?2004h[?25h[?25l[56;1H[K[1;5H[56;1HExecuting CursorMoved Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lautocommand call s:Highlight_Matching_Pair()
Interrupt: [38;5;121mPress ENTER or type command to continue[?25h[m
[?25lline 0: call s:Highlight_Matching_Pair()
calling function <SNR>19_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     silent! call matchdelete(3)
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6:
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12:
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17:
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:[7Clet before = strlen(c_before)
line 31:[7Clet c = c_before
line 32:[7Clet i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:[7C" not found, nothing to do
line 36:[7Creturn
function <SNR>19_Highlight_Matching_Pair returning #0
continuing in CursorMoved Autocommands for "*"
Executing CursorMoved Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lautocommand call s:OnCursorMovedNormalMode()
[38;5;121mPress ENTER or type command to continue[?25h[m
[?25lline 0: call s:OnCursorMovedNormalMode()
[27m[23m[29m[m[H[2J[1;1H[93m  0 [m[48;5;234m¬                                                                                   [m[48;5;236m [m[48;5;234m                [m[2;1H[38;5;231m~                                                                                                        [3;1H~                                                                                                        [4;1H~                                                                                                        [5;1H~                                                                                                        [6;1H~                                                                                                        [7;1H~                                                                                                        [8;1H~                                                                                                        [9;1H~                                                                                                        [10;1H~                                                                                                        [11;1H~                                                                                                        [12;1H~                                                                                                        [13;1H~                                                                                                        [14;1H~                                                                                                        [15;1H~                                                                                                        [16;1H~                                                                                                        [17;1H~                                                                                                        [18;1H~                                                                                                        [19;1H~                                                                                                        [20;1H~                                                                                                        [21;1H~                                                                                                        [22;1H~                                                                                                        [23;1H~                                                                                                        [24;1H~                                                                                                        [25;1H~                                                                                                        [26;1H~                                                                                                        [27;1H~                                                                                                        [28;1H~                                                                                                        [29;1H~                                                                                                        [30;1H~                                                                                                        [31;1H~                                                                                                        [32;1H~                                                                                                        [33;1H~                                                                                                        [34;1H~                                                                                                        [35;1H~                                                                                                        [36;1H~                                                                                                        [37;1H~                                                                                                        [38;1H~                                                                                                        [39;1H~                                                                                                        [40;1H~                                                                                                        [41;1H~                                                                                                        [42;1H~                                                                                                        [43;1H~                                                                                                        [44;1H~                                                                                                        [45;1H~                                                                                                        [46;1H~                                                                                                        [47;1H~                                                                                                        [48;1H~                                                                                                        [49;1H~                                                                                                        [50;1H~                                                                                                        [51;1H~                                                                                                        [52;1H~                                                                                                        [53;1H~                                                                                                        [54;1H~                                                                                                        [m[55;1H[1m[38;5;231m[48;5;236m[No Name]                                                                              0,0-1          All[m[22;45HVIM - Vi IMproved[24;46Hversion 8.1.194[25;41Hby Bram Moolenaar et al.[26;32HVim is open source and freely distributable[28;39HHelp poor children in Uganda![29;30Htype  :help iccf[38;5;231m[48;5;235m<Enter>[m       for information [31;30Htype  :q[38;5;231m[48;5;235m<Enter>[m               to exit         [32;30Htype  :help[38;5;231m[48;5;235m<Enter>[m  or  [38;5;231m[48;5;235m<F1>[m  for on-line help[33;30Htype  :help version8[38;5;231m[48;5;235m<Enter>[m   for version info[1;5H[?25h[?25l[56;1HType  :qa!  and press <Enter> to abandon all changes and exit Vim[?5h[?25h[?5l[1;5H[?25l[?5h[?25h[?5l[?25l[56;95H:[1;5H[56;1H[K[56;1H:[?2004h[?25hq[?25l[?25h[?25lExecuting BufUnload Autocommands for "*"
autocommand call s:OnBufferUnload( expand( '<afile>:p' ) )
line 0: call s:OnBufferUnload( expand( '<afile>:p' ) )
calling function <SNR>27_OnBufferUnload('')
line 1:   if !s:AllowedToCompleteInCurrentBuffer() || empty( a:deleted_buffer_file )
calling function <SNR>27_OnBufferUnload[1]..<SNR>27_AllowedToCompleteInCurrentBuffer()
line 1:   if empty( &filetype ) || getbufvar( winbufnr( winnr() ), "&buftype" ) ==# 'nofile' || &filetyp
[55;105He[56;2H==# 'qf'
line 4:     return 0
function <SNR>27_OnBufferUnload[1]..<SNR>27_AllowedToCompleteInCurrentBuffer returning #0
continuing in function <SNR>27_OnBufferUnload
line 2:     return
function <SNR>27_OnBufferUnload returning #0
continuing in BufUnload Autocommands for "*"
Writing viminfo file "/home/connor/.viminfo"
Executing VimLeave Autocommands for "*"
autocommand call s:OnVimLeave()
line 0: call s:OnVimLeave()
calling function <SNR>27_OnVimLeave()
line 1:   exec s:python_command "ycm_state.OnVimLeave()"
line 1: py  ycm_state.OnVimLeave()
[38;5;231m[48;5;212mError detected while processing function <SNR>27_OnVimLeave:[m
[38;5;60mline    1:[m
[38;5;231m[48;5;212mTraceback (most recent call last):[m
[38;5;231m[48;5;212m  File "<string>", line 1, in <module>[m
[38;5;231m[48;5;212mNameError: name 'ycm_state' is not defined[m
function <SNR>27_OnVimLeave returning #0
continuing in VimLeave Autocommands for "*"
[?2004l[?2004l[?1l>[?25h[?1049l[23;0;0t
